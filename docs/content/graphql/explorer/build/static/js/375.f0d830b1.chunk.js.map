{"version":3,"file":"static/js/375.f0d830b1.chunk.js","mappings":"yHAgCA,IAAIA,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EA4BJ,SAASC,IACP,IAAMC,EAAYN,EACZO,EAAU,GAEhB,GADAC,EAAO,MACFC,EAAK,KAAM,CACd,GACEF,EAAQG,KAAKC,WACNF,EAAK,MACdD,EAAO,KAET,MAAO,CACLJ,KAAM,SACNJ,MAAOM,EACPL,IAAKC,EACLK,QAAO,GAIX,SAASI,IACP,IAAML,EAAYN,EACZY,EAAe,WAATR,EAAoBS,IAAa,KAC7CL,EAAO,UACPA,EAAO,KACP,IAAMM,EAAQC,IACd,MAAO,CACLX,KAAM,SACNJ,MAAOM,EACPL,IAAKC,EACLU,IAAG,EACHE,MAAK,GAsBT,SAASC,IACP,OAAQX,GACN,IAAK,IACH,OArBN,WACE,IAAME,EAAYN,EACZgB,EAAS,GAEf,GADAR,EAAO,MACFC,EAAK,KAAM,CACd,GACEO,EAAON,KAAKK,WACLN,EAAK,MACdD,EAAO,KAET,MAAO,CACLJ,KAAM,QACNJ,MAAOM,EACPL,IAAKC,EACLc,OAAM,GAOGC,GACT,IAAK,IACH,OAAOZ,IACT,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,OACH,IAAMa,EAAQL,IAEd,OADAM,IACOD,EAEXV,EAAO,SAGT,SAASK,IACP,MAAO,CAAET,KAAI,EAAEJ,MAAK,EAAEC,IAAG,EAAEa,MAAOM,KAAKC,MAAMvB,EAAOwB,MAAMtB,EAAOC,KAGnE,SAASO,EAAOe,GACd,GAAInB,IAASmB,EAAb,CAKA,IAAIC,EACJ,GAAa,QAATpB,EACFoB,EAAQ,qBACH,GAAIvB,EAAMD,EAAQ,EACvBwB,EAAQ,IAAM1B,EAAOwB,MAAMtB,EAAOC,GAAO,QACpC,CACL,IAAMwB,EAAQ3B,EAAOwB,MAAMtB,GAAOyB,MAAM,UACxCD,EAAQ,KAAOC,EAAQA,EAAM,GAAK3B,EAAOE,IAAU,IAGrD,MAAM0B,EAAY,YAAYH,EAAG,cAAcC,EAAK,KAdlDL,IAiBJ,SAASO,EAAYC,GACnB,MAAO,CAAEA,QAAO,EAAE3B,MAAK,EAAEC,IAAG,GAG9B,SAASQ,EAAKmB,GACZ,GAAIxB,IAASwB,EAEX,OADAT,KACO,EAIX,SAASU,IAKP,OAJI5B,EAAMF,IACRE,IACAE,EAAOF,IAAQF,EAAS,EAAID,EAAOgC,WAAW7B,IAEzCE,EAGT,SAASgB,IAGP,IAFAjB,EAAUD,EAEM,IAATE,GAAuB,KAATA,GAAwB,KAATA,GAAwB,KAATA,GACjD0B,IAGF,GAAa,IAAT1B,EAAJ,CAOA,OAFAH,EAAQC,EAEAE,GAEN,KAAK,GAEH,OADAC,EAAO,SAoDb,WACEyB,IACA,KAAgB,KAAT1B,GAAeA,EAAO,IAC3B,GAAa,KAATA,EAGF,OADAA,EAAO0B,KAEL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACHA,IACA,MACF,KAAK,IACHA,IACAE,IACAA,IACAA,IACAA,IACA,MACF,QACE,MAAML,EAAY,sCAEjB,IAAIzB,IAAQF,EACjB,MAAM2B,EAAY,wBAElBG,IAIJ,GAAa,KAAT1B,EAEF,YADA0B,IAIF,MAAMH,EAAY,wBA1FPM,GAET,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GAEH,OADA5B,EAAO,SA2Fb,WACe,KAATD,GAEF0B,IAGW,KAAT1B,EAEF0B,IAEAI,IAGW,KAAT9B,IAEF0B,IACAI,KAGW,KAAT9B,GAAwB,MAATA,IAGJ,MADbA,EAAO0B,MACqB,KAAT1B,GAEjB0B,IAEFI,KApHSC,GAET,KAAK,IACH,GAAuC,UAAnCpC,EAAOwB,MAAMtB,EAAOA,EAAQ,GAC9B,MAMF,OAJAC,GAAO,EACP4B,SAEAzB,EAAO,WAGT,KAAK,IACH,GAAuC,SAAnCN,EAAOwB,MAAMtB,EAAOA,EAAQ,GAC9B,MAMF,OAJAC,GAAO,EACP4B,SAEAzB,EAAO,QAGT,KAAK,IACH,GAAuC,SAAnCN,EAAOwB,MAAMtB,EAAOA,EAAQ,GAC9B,MAMF,OAJAC,GAAO,EACP4B,SAEAzB,EAAO,WAIXA,EAAON,EAAOE,GACd6B,SA1DEzB,EAAO,MAuGX,SAAS2B,IACP,GACG5B,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,IAEvB,OAAO0B,IAET,MAAMH,EAAY,+BAiCpB,SAASO,IACP,GAAI9B,EAAO,IAAMA,EAAO,GAEtB,MAAMuB,EAAY,2BAEpB,GACEG,UACO1B,GAAQ,IAAMA,GAAQ,I,iDA1TjCgC,EAAAA,QAAA,SAAkCZ,GAChCzB,EAASyB,EACTxB,EAASwB,EAAIa,OACbpC,EAAQC,EAAMC,GAAW,EACzB2B,IACAV,IACA,IAAMkB,EAAMhC,IAEZ,OADAG,EAAO,OACA6B,I,ucCpBT,iBACA,UASA,aA2FA,SAASC,EACPC,EACAC,GAGA,IAAKD,IAASC,EACZ,MAAO,GAIT,GAAID,aAAgBE,EAAAA,eAClB,MAAsB,SAAlBD,EAASpC,KACJ,CAAC,CAACoC,EAAU,SAASD,EAAI,0CAE3BD,EAAcC,EAAKG,OAAQF,GAGpC,GAAsB,SAAlBA,EAASpC,KACX,MAAO,GAIT,GAAImC,aAAgBE,EAAAA,YAAa,CAC/B,IAAME,EAAWJ,EAAKG,OACtB,MAAsB,UAAlBF,EAASpC,KAEJwC,EADSJ,EAA8BxB,QAAU,IAClC,SAAA6B,GAAQ,OAAAP,EAAcK,EAAUE,MAEjDP,EAAcK,EAAUH,GAIjC,GAAID,aAAgBE,EAAAA,uBAAwB,CAC1C,GAAsB,WAAlBD,EAASpC,KACX,MAAO,CAAC,CAACoC,EAAU,SAASD,EAAI,yBAIlC,IAAMO,EAAiBC,OAAOC,OAAO,MAC/BC,EAAuBL,EAC1BJ,EAA+BjC,SAChC,SAAA2C,G,MAEQC,EAAuB,QAAd,EAAS,OAAND,QAAM,IAANA,OAAM,EAANA,EAAQtC,WAAGwC,IAAAA,OAAA,EAAAA,EAAEtC,MAC/BgC,EAAeK,IAAa,EAC5B,IAAME,EAAad,EAAKe,YAAYH,GACpC,OAAKE,EASEf,EADWe,EAAaA,EAAWd,UAAOgB,EACjBL,EAAOpC,OAR9B,CACL,CACEoC,EAAOtC,IACP,SAAS2B,EAAI,4BAA4BY,EAAS,UAsB5D,OAZAJ,OAAOS,KAAKjB,EAAKe,aAAaG,SAAQ,SAAAN,GAC/BL,EAAeK,IACAZ,EAAKe,YAAYH,GAAWZ,gBACrBE,EAAAA,gBACvBQ,EAAYvC,KAAK,CACf8B,EACA,mBAAmBD,EAAI,gCAAgCY,EAAS,UAMjEF,EAIT,MACiB,YAAdV,EAAKmB,MAAwC,YAAlBlB,EAASpC,MACtB,WAAdmC,EAAKmB,MAAuC,WAAlBlB,EAASpC,MACrB,OAAdmC,EAAKmB,MACc,WAAlBlB,EAASpC,MACS,WAAlBoC,EAASpC,MACI,UAAdmC,EAAKmB,MAAsC,WAAlBlB,EAASpC,MACpB,QAAdmC,EAAKmB,OAEe,WAAlBlB,EAASpC,OAAuC,EAAjBoC,EAAS1B,SAAe0B,EAAS1B,SAMjEyB,aAAgBE,EAAAA,iBAAmBF,aAAgBE,EAAAA,qBAEhC,WAAlBD,EAASpC,MACU,WAAlBoC,EAASpC,MACS,YAAlBoC,EAASpC,MACS,SAAlBoC,EAASpC,OA4BE,QAFAU,EAzBHyB,EAAKoB,WAAWnB,EAAS1B,cA2BJyC,IAAVzC,GAAuBA,IAAUA,IArCjD,CAAC,CAAC0B,EAAU,2BAA2BD,EAAI,OAgB7C,GAmBT,IAAmBzB,EAdnB,SAAS8C,EACPC,EACAC,EACAnC,GAEA,MAAO,CACLA,QAAO,EACPoC,SAAU,QACVxB,KAAM,aACNyB,KAAMH,EAAOI,aAAaH,EAAK9D,OAC/BkE,GAAIL,EAAOI,aAAaH,EAAK7D,MASjC,SAAS2C,EAAauB,EAAYC,GAChC,OAAOC,MAAMC,UAAUC,OAAOC,MAAM,GAAIL,EAAMM,IAAIL,IApMpDM,EAAAA,QAAWC,eACT,OACA,qBACA,SACEC,EACAC,EACAhB,GAGA,IAAKe,EACH,MAAO,GAIT,IAAIvC,EACJ,IACEA,EAAMyC,EAAAA,QAAUF,GAChB,MAAOlD,GACP,GAAIA,EAAYqD,MACd,MAAMrD,EAER,MAAO,CAACkC,EAAUC,EAAQnC,EAAaA,EAAYC,UAIrD,IAAMqD,EAAiBH,EAAQG,eAC/B,OAAKA,EAWT,SACEnB,EACAmB,EACAC,GAEA,IAAMC,EAAkC,GAsBxC,OApBAD,EAAa1E,QAAQkD,SAAQ,SAAAP,G,MAC3B,GAAIA,EAAQ,CACV,IAAMiC,EAAyB,QAAb,EAAGjC,EAAOtC,WAAGwC,IAAAA,OAAA,EAAAA,EAAEtC,MAC3ByB,EAAOyC,EAAeG,GACvB5C,EASHD,EAAcC,EAAMW,EAAOpC,OAAO2C,SAAQ,SAACL,G,IAAAgC,EAAAA,EAAAA,EAAAA,GAACtB,EAAI,KAAEnC,EAAO,KACvDuD,EAAOxE,KAAKkD,EAAUC,EAAQC,EAAMnC,OATtCuD,EAAOxE,KACLkD,EACEC,EACAX,EAAOtC,IACP,cAAcuE,EAAY,gDAW7BD,EAjCEG,CAAkBxB,EAAQmB,EAAgB3C,GAJxC","sources":["../../../node_modules/codemirror-graphql/src/utils/jsonParse.ts","../../../node_modules/codemirror-graphql/src/variables/lint.ts"],"sourcesContent":["/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * This JSON parser simply walks the input, generating an AST. Use this in lieu\n * of JSON.parse if you need character offset parse errors and an AST parse tree\n * with location information.\n *\n * If an error is encountered, a SyntaxError will be thrown, with properties:\n *\n *   - message: string\n *   - start: int - the start inclusive offset of the syntax error\n *   - end: int - the end exclusive offset of the syntax error\n *\n */\nexport default function jsonParse(str: string) {\n  string = str;\n  strLen = str.length;\n  start = end = lastEnd = -1;\n  ch();\n  lex();\n  const ast = parseObj();\n  expect('EOF');\n  return ast;\n}\n\nlet string: string;\nlet strLen: number;\nlet start: number;\nlet end: number;\nlet lastEnd: number;\nlet code: number;\nlet kind: string;\n\ninterface BaseParseOutput {\n  kind: string;\n  start: number;\n  end: number;\n}\nexport interface ParseTokenOutput extends BaseParseOutput {\n  value: any;\n}\nexport interface ParseObjectOutput extends BaseParseOutput {\n  kind: 'Object';\n  members: ParseMemberOutput[];\n}\nexport interface ParseArrayOutput extends BaseParseOutput {\n  kind: 'Array';\n  values?: ParseValueOutput[];\n}\nexport interface ParseMemberOutput extends BaseParseOutput {\n  key: ParseTokenOutput | null;\n  value?: ParseValueOutput;\n}\nexport type ParseValueOutput =\n  | ParseTokenOutput\n  | ParseObjectOutput\n  | ParseArrayOutput\n  | undefined;\n\nfunction parseObj(): ParseObjectOutput {\n  const nodeStart = start;\n  const members = [];\n  expect('{');\n  if (!skip('}')) {\n    do {\n      members.push(parseMember());\n    } while (skip(','));\n    expect('}');\n  }\n  return {\n    kind: 'Object',\n    start: nodeStart,\n    end: lastEnd,\n    members,\n  };\n}\n\nfunction parseMember(): ParseMemberOutput {\n  const nodeStart = start;\n  const key = kind === 'String' ? curToken() : null;\n  expect('String');\n  expect(':');\n  const value = parseVal();\n  return {\n    kind: 'Member',\n    start: nodeStart,\n    end: lastEnd,\n    key,\n    value,\n  };\n}\n\nfunction parseArr(): ParseArrayOutput {\n  const nodeStart = start;\n  const values = [];\n  expect('[');\n  if (!skip(']')) {\n    do {\n      values.push(parseVal());\n    } while (skip(','));\n    expect(']');\n  }\n  return {\n    kind: 'Array',\n    start: nodeStart,\n    end: lastEnd,\n    values,\n  };\n}\n\nfunction parseVal(): ParseValueOutput | undefined {\n  switch (kind) {\n    case '[':\n      return parseArr();\n    case '{':\n      return parseObj();\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Null':\n      const token = curToken();\n      lex();\n      return token;\n  }\n  expect('Value');\n}\n\nfunction curToken(): ParseTokenOutput {\n  return { kind, start, end, value: JSON.parse(string.slice(start, end)) };\n}\n\nfunction expect(str: string) {\n  if (kind === str) {\n    lex();\n    return;\n  }\n\n  let found;\n  if (kind === 'EOF') {\n    found = '[end of file]';\n  } else if (end - start > 1) {\n    found = '`' + string.slice(start, end) + '`';\n  } else {\n    const match = string.slice(start).match(/^.+?\\b/);\n    found = '`' + (match ? match[0] : string[start]) + '`';\n  }\n\n  throw syntaxError(`Expected ${str} but found ${found}.`);\n}\n\nfunction syntaxError(message: string) {\n  return { message, start, end };\n}\n\nfunction skip(k: string) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\n\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code = end === strLen ? 0 : string.charCodeAt(end);\n  }\n  return code;\n}\n\nfunction lex() {\n  lastEnd = end;\n\n  while (code === 9 || code === 10 || code === 13 || code === 32) {\n    ch();\n  }\n\n  if (code === 0) {\n    kind = 'EOF';\n    return;\n  }\n\n  start = end;\n\n  switch (code) {\n    // \"\n    case 34:\n      kind = 'String';\n      return readString();\n    // -, 0-9\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      kind = 'Number';\n      return readNumber();\n    // f\n    case 102:\n      if (string.slice(start, start + 5) !== 'false') {\n        break;\n      }\n      end += 4;\n      ch();\n\n      kind = 'Boolean';\n      return;\n    // n\n    case 110:\n      if (string.slice(start, start + 4) !== 'null') {\n        break;\n      }\n      end += 3;\n      ch();\n\n      kind = 'Null';\n      return;\n    // t\n    case 116:\n      if (string.slice(start, start + 4) !== 'true') {\n        break;\n      }\n      end += 3;\n      ch();\n\n      kind = 'Boolean';\n      return;\n  }\n\n  kind = string[start];\n  ch();\n}\n\nfunction readString() {\n  ch();\n  while (code !== 34 && code > 31) {\n    if (code === 92) {\n      // \\\n      code = ch();\n      switch (code) {\n        case 34: // \"\n        case 47: // /\n        case 92: // \\\n        case 98: // b\n        case 102: // f\n        case 110: // n\n        case 114: // r\n        case 116: // t\n          ch();\n          break;\n        case 117: // u\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n        default:\n          throw syntaxError('Bad character escape sequence.');\n      }\n    } else if (end === strLen) {\n      throw syntaxError('Unterminated string.');\n    } else {\n      ch();\n    }\n  }\n\n  if (code === 34) {\n    ch();\n    return;\n  }\n\n  throw syntaxError('Unterminated string.');\n}\n\nfunction readHex() {\n  if (\n    (code >= 48 && code <= 57) || // 0-9\n    (code >= 65 && code <= 70) || // A-F\n    (code >= 97 && code <= 102) // a-f\n  ) {\n    return ch();\n  }\n  throw syntaxError('Expected hexadecimal digit.');\n}\n\nfunction readNumber() {\n  if (code === 45) {\n    // -\n    ch();\n  }\n\n  if (code === 48) {\n    // 0\n    ch();\n  } else {\n    readDigits();\n  }\n\n  if (code === 46) {\n    // .\n    ch();\n    readDigits();\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    code = ch();\n    if (code === 43 || code === 45) {\n      // + -\n      ch();\n    }\n    readDigits();\n  }\n}\n\nfunction readDigits() {\n  if (code < 48 || code > 57) {\n    // 0 - 9\n    throw syntaxError('Expected decimal digit.');\n  }\n  do {\n    ch();\n  } while (code >= 48 && code <= 57); // 0 - 9\n}\n","/**\n *  Copyright (c) 2021 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport CodeMirror from 'codemirror';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLType,\n} from 'graphql';\n\nimport jsonParse, {\n  ParseArrayOutput,\n  ParseObjectOutput,\n  ParseValueOutput,\n} from '../utils/jsonParse';\nimport { VariableToType } from './hint';\n\ninterface GraphQLVariableLintOptions {\n  variableToType: VariableToType;\n}\n\n/**\n * Registers a \"lint\" helper for CodeMirror.\n *\n * Using CodeMirror's \"lint\" addon: https://codemirror.net/demo/lint.html\n * Given the text within an editor, this helper will take that text and return\n * a list of linter issues ensuring that correct variables were provided.\n *\n * Options:\n *\n *   - variableToType: { [variable: string]: GraphQLInputType }\n *\n */\nCodeMirror.registerHelper(\n  'lint',\n  'graphql-variables',\n  (\n    text: string,\n    options: GraphQLVariableLintOptions,\n    editor: CodeMirror.Editor,\n  ) => {\n    // If there's no text, do nothing.\n    if (!text) {\n      return [];\n    }\n\n    // First, linter needs to determine if there are any parsing errors.\n    let ast;\n    try {\n      ast = jsonParse(text);\n    } catch (syntaxError) {\n      if (syntaxError.stack) {\n        throw syntaxError;\n      }\n      return [lintError(editor, syntaxError, syntaxError.message)];\n    }\n\n    // If there are not yet known variables, do nothing.\n    const variableToType = options.variableToType;\n    if (!variableToType) {\n      return [];\n    }\n\n    // Then highlight any issues with the provided variables.\n    return validateVariables(editor, variableToType, ast);\n  },\n);\n\n// Given a variableToType object, a source text, and a JSON AST, produces a\n// list of CodeMirror annotations for any variable validation errors.\nfunction validateVariables(\n  editor: CodeMirror.Editor,\n  variableToType: VariableToType,\n  variablesAST: ParseObjectOutput,\n) {\n  const errors: CodeMirror.Annotation[] = [];\n\n  variablesAST.members.forEach(member => {\n    if (member) {\n      const variableName = member.key?.value;\n      const type = variableToType[variableName];\n      if (!type) {\n        errors.push(\n          lintError(\n            editor,\n            member.key!,\n            `Variable \"$${variableName}\" does not appear in any GraphQL query.`,\n          ),\n        );\n      } else {\n        validateValue(type, member.value).forEach(([node, message]) => {\n          errors.push(lintError(editor, node, message));\n        });\n      }\n    }\n  });\n\n  return errors;\n}\n\n// Returns a list of validation errors in the form Array<[Node, String]>.\nfunction validateValue(\n  type?: GraphQLType,\n  valueAST?: ParseValueOutput,\n): any[][] {\n  // TODO: Can't figure out the right type.\n  if (!type || !valueAST) {\n    return [];\n  }\n\n  // Validate non-nullable values.\n  if (type instanceof GraphQLNonNull) {\n    if (valueAST.kind === 'Null') {\n      return [[valueAST, `Type \"${type}\" is non-nullable and cannot be null.`]];\n    }\n    return validateValue(type.ofType, valueAST);\n  }\n\n  if (valueAST.kind === 'Null') {\n    return [];\n  }\n\n  // Validate lists of values, accepting a non-list as a list of one.\n  if (type instanceof GraphQLList) {\n    const itemType = type.ofType;\n    if (valueAST.kind === 'Array') {\n      const values = (valueAST as ParseArrayOutput).values || [];\n      return mapCat(values, item => validateValue(itemType, item));\n    }\n    return validateValue(itemType, valueAST);\n  }\n\n  // Validate input objects.\n  if (type instanceof GraphQLInputObjectType) {\n    if (valueAST.kind !== 'Object') {\n      return [[valueAST, `Type \"${type}\" must be an Object.`]];\n    }\n\n    // Validate each field in the input object.\n    const providedFields = Object.create(null);\n    const fieldErrors: any[][] = mapCat(\n      (valueAST as ParseObjectOutput).members,\n      member => {\n        // TODO: Can't figure out the right type here\n        const fieldName = member?.key?.value;\n        providedFields[fieldName] = true;\n        const inputField = type.getFields()[fieldName];\n        if (!inputField) {\n          return [\n            [\n              member.key,\n              `Type \"${type}\" does not have a field \"${fieldName}\".`,\n            ],\n          ];\n        }\n        const fieldType = inputField ? inputField.type : undefined;\n        return validateValue(fieldType, member.value);\n      },\n    );\n\n    // Look for missing non-nullable fields.\n    Object.keys(type.getFields()).forEach(fieldName => {\n      if (!providedFields[fieldName]) {\n        const fieldType = type.getFields()[fieldName].type;\n        if (fieldType instanceof GraphQLNonNull) {\n          fieldErrors.push([\n            valueAST,\n            `Object of type \"${type}\" is missing required field \"${fieldName}\".`,\n          ]);\n        }\n      }\n    });\n\n    return fieldErrors;\n  }\n\n  // Validate common scalars.\n  if (\n    (type.name === 'Boolean' && valueAST.kind !== 'Boolean') ||\n    (type.name === 'String' && valueAST.kind !== 'String') ||\n    (type.name === 'ID' &&\n      valueAST.kind !== 'Number' &&\n      valueAST.kind !== 'String') ||\n    (type.name === 'Float' && valueAST.kind !== 'Number') ||\n    (type.name === 'Int' &&\n      // eslint-disable-next-line no-bitwise\n      (valueAST.kind !== 'Number' || (valueAST.value | 0) !== valueAST.value))\n  ) {\n    return [[valueAST, `Expected value of type \"${type}\".`]];\n  }\n\n  // Validate enums and custom scalars.\n  if (type instanceof GraphQLEnumType || type instanceof GraphQLScalarType) {\n    if (\n      (valueAST.kind !== 'String' &&\n        valueAST.kind !== 'Number' &&\n        valueAST.kind !== 'Boolean' &&\n        valueAST.kind !== 'Null') ||\n      isNullish(type.parseValue(valueAST.value))\n    ) {\n      return [[valueAST, `Expected value of type \"${type}\".`]];\n    }\n  }\n\n  return [];\n}\n\n// Give a parent text, an AST node with location, and a message, produces a\n// CodeMirror annotation object.\nfunction lintError(\n  editor: CodeMirror.Editor,\n  node: { start: number; end: number },\n  message: string,\n): CodeMirror.Annotation & { type: string } {\n  return {\n    message,\n    severity: 'error',\n    type: 'validation',\n    from: editor.posFromIndex(node.start),\n    to: editor.posFromIndex(node.end),\n  };\n}\n\nfunction isNullish(value: any): boolean {\n  // eslint-disable-next-line no-self-compare\n  return value === null || value === undefined || value !== value;\n}\n\nfunction mapCat<T, R>(array: T[], mapper: (item: T) => R[]): R[] {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n"],"names":["string","strLen","start","end","lastEnd","code","kind","parseObj","nodeStart","members","expect","skip","push","parseMember","key","curToken","value","parseVal","values","parseArr","token","lex","JSON","parse","slice","str","found","match","syntaxError","message","k","ch","charCodeAt","readHex","readString","readDigits","readNumber","exports","length","ast","validateValue","type","valueAST","graphql_1","ofType","itemType_1","mapCat","item","providedFields_1","Object","create","fieldErrors_1","member","fieldName","_a","inputField","getFields","undefined","keys","forEach","name","parseValue","lintError","editor","node","severity","from","posFromIndex","to","array","mapper","Array","prototype","concat","apply","map","codemirror_1","registerHelper","text","options","jsonParse_1","stack","variableToType","variablesAST","errors","variableName","_b","validateVariables"],"sourceRoot":""}