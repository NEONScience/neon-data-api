{"version":3,"file":"static/js/141.3b84b44f.chunk.js","mappings":"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","sources":["../../../node_modules/@graphiql/react/dist/Range.es.js","../../../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs","../../../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs","../../../node_modules/graphql/language/predicates.mjs","../../../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs","../../../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs","../../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs","../../../node_modules/graphql/jsutils/groupBy.mjs","../../../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs","../../../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs","../../../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs","../../../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs","../../../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs","../../../node_modules/graphql/utilities/sortValueNode.mjs","../../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs","../../../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs","../../../node_modules/graphql/execution/values.mjs","../../../node_modules/graphql/execution/collectFields.mjs","../../../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs","../../../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs","../../../node_modules/graphql/validation/specifiedRules.mjs","../../../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs","../../../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs","../../../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs","../../../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs","../../../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs","../../../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs","../../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs","../../../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs","../../../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs","../../../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs","../../../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs","../../../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs","../../../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs","../../../node_modules/graphql/validation/ValidationContext.mjs","../../../node_modules/graphql/validation/validate.mjs","../../../node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs","../../../node_modules/@graphiql/react/dist/lint.es.js","../../../node_modules/@graphiql/react/dist/onlineParser.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nclass CharacterStream {\n  constructor(sourceText) {\n    this.getStartOfToken = () => this._start;\n    this.getCurrentPosition = () => this._pos;\n    this.eol = () => this._sourceText.length === this._pos;\n    this.sol = () => this._pos === 0;\n    this.peek = () => {\n      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;\n    };\n    this.next = () => {\n      const char = this._sourceText.charAt(this._pos);\n      this._pos++;\n      return char;\n    };\n    this.eat = (pattern) => {\n      const isMatched = this._testNextCharacter(pattern);\n      if (isMatched) {\n        this._start = this._pos;\n        this._pos++;\n        return this._sourceText.charAt(this._pos - 1);\n      }\n      return void 0;\n    };\n    this.eatWhile = (match) => {\n      let isMatched = this._testNextCharacter(match);\n      let didEat = false;\n      if (isMatched) {\n        didEat = isMatched;\n        this._start = this._pos;\n      }\n      while (isMatched) {\n        this._pos++;\n        isMatched = this._testNextCharacter(match);\n        didEat = true;\n      }\n      return didEat;\n    };\n    this.eatSpace = () => this.eatWhile(/[\\s\\u00a0]/);\n    this.skipToEnd = () => {\n      this._pos = this._sourceText.length;\n    };\n    this.skipTo = (position) => {\n      this._pos = position;\n    };\n    this.match = (pattern, consume = true, caseFold = false) => {\n      let token = null;\n      let match = null;\n      if (typeof pattern === \"string\") {\n        const regex = new RegExp(pattern, caseFold ? \"i\" : \"g\");\n        match = regex.test(this._sourceText.substr(this._pos, pattern.length));\n        token = pattern;\n      } else if (pattern instanceof RegExp) {\n        match = this._sourceText.slice(this._pos).match(pattern);\n        token = match === null || match === void 0 ? void 0 : match[0];\n      }\n      if (match != null) {\n        if (typeof pattern === \"string\" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {\n          if (consume) {\n            this._start = this._pos;\n            if (token && token.length) {\n              this._pos += token.length;\n            }\n          }\n          return match;\n        }\n      }\n      return false;\n    };\n    this.backUp = (num) => {\n      this._pos -= num;\n    };\n    this.column = () => this._pos;\n    this.indentation = () => {\n      const match = this._sourceText.match(/\\s*/);\n      let indent = 0;\n      if (match && match.length !== 0) {\n        const whiteSpaces = match[0];\n        let pos = 0;\n        while (whiteSpaces.length > pos) {\n          if (whiteSpaces.charCodeAt(pos) === 9) {\n            indent += 2;\n          } else {\n            indent++;\n          }\n          pos++;\n        }\n      }\n      return indent;\n    };\n    this.current = () => this._sourceText.slice(this._start, this._pos);\n    this._start = 0;\n    this._pos = 0;\n    this._sourceText = sourceText;\n  }\n  _testNextCharacter(pattern) {\n    const character = this._sourceText.charAt(this._pos);\n    let isMatched = false;\n    if (typeof pattern === \"string\") {\n      isMatched = character === pattern;\n    } else {\n      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);\n    }\n    return isMatched;\n  }\n}\n__name(CharacterStream, \"CharacterStream\");\nclass Range {\n  constructor(start, end) {\n    this.containsPosition = (position) => {\n      if (this.start.line === position.line) {\n        return this.start.character <= position.character;\n      } else if (this.end.line === position.line) {\n        return this.end.character >= position.character;\n      } else {\n        return this.start.line <= position.line && this.end.line >= position.line;\n      }\n    };\n    this.start = start;\n    this.end = end;\n  }\n  setStart(line, character) {\n    this.start = new Position(line, character);\n  }\n  setEnd(line, character) {\n    this.end = new Position(line, character);\n  }\n}\n__name(Range, \"Range\");\nclass Position {\n  constructor(line, character) {\n    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;\n    this.line = line;\n    this.character = character;\n  }\n  setLine(line) {\n    this.line = line;\n  }\n  setCharacter(character) {\n    this.character = character;\n  }\n}\n__name(Position, \"Position\");\nexport { CharacterStream as C, Position as P, Range as R };\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Lone Schema definition\n *\n * A GraphQL document is only valid if it contains only one schema definition.\n */\nexport function LoneSchemaDefinitionRule(context) {\n  var _ref, _ref2, _oldSchema$astNode;\n\n  const oldSchema = context.getSchema();\n  const alreadyDefined =\n    (_ref =\n      (_ref2 =\n        (_oldSchema$astNode =\n          oldSchema === null || oldSchema === void 0\n            ? void 0\n            : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0\n          ? _oldSchema$astNode\n          : oldSchema === null || oldSchema === void 0\n          ? void 0\n          : oldSchema.getQueryType()) !== null && _ref2 !== void 0\n        ? _ref2\n        : oldSchema === null || oldSchema === void 0\n        ? void 0\n        : oldSchema.getMutationType()) !== null && _ref !== void 0\n      ? _ref\n      : oldSchema === null || oldSchema === void 0\n      ? void 0\n      : oldSchema.getSubscriptionType();\n  let schemaDefinitionsCount = 0;\n  return {\n    SchemaDefinition(node) {\n      if (alreadyDefined) {\n        context.reportError(\n          new GraphQLError(\n            'Cannot define a new schema within a schema extension.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (schemaDefinitionsCount > 0) {\n        context.reportError(\n          new GraphQLError('Must provide only one schema definition.', {\n            nodes: node,\n          }),\n        );\n      }\n\n      ++schemaDefinitionsCount;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation types\n *\n * A GraphQL document is only valid if it has only one type per operation.\n */\nexport function UniqueOperationTypesRule(context) {\n  const schema = context.getSchema();\n  const definedOperationTypes = Object.create(null);\n  const existingOperationTypes = schema\n    ? {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n      }\n    : {};\n  return {\n    SchemaDefinition: checkOperationTypes,\n    SchemaExtension: checkOperationTypes,\n  };\n\n  function checkOperationTypes(node) {\n    var _node$operationTypes;\n\n    // See: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const operationTypesNodes =\n      (_node$operationTypes = node.operationTypes) !== null &&\n      _node$operationTypes !== void 0\n        ? _node$operationTypes\n        : [];\n\n    for (const operationType of operationTypesNodes) {\n      const operation = operationType.operation;\n      const alreadyDefinedOperationType = definedOperationTypes[operation];\n\n      if (existingOperationTypes[operation]) {\n        context.reportError(\n          new GraphQLError(\n            `Type for ${operation} already defined in the schema. It cannot be redefined.`,\n            {\n              nodes: operationType,\n            },\n          ),\n        );\n      } else if (alreadyDefinedOperationType) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one ${operation} type in schema.`,\n            {\n              nodes: [alreadyDefinedOperationType, operationType],\n            },\n          ),\n        );\n      } else {\n        definedOperationTypes[operation] = operationType;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique type names\n *\n * A GraphQL document is only valid if all defined types have unique names.\n */\nexport function UniqueTypeNamesRule(context) {\n  const knownTypeNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    ScalarTypeDefinition: checkTypeName,\n    ObjectTypeDefinition: checkTypeName,\n    InterfaceTypeDefinition: checkTypeName,\n    UnionTypeDefinition: checkTypeName,\n    EnumTypeDefinition: checkTypeName,\n    InputObjectTypeDefinition: checkTypeName,\n  };\n\n  function checkTypeName(node) {\n    const typeName = node.name.value;\n\n    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {\n      context.reportError(\n        new GraphQLError(\n          `Type \"${typeName}\" already exists in the schema. It cannot also be defined in this type definition.`,\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n      return;\n    }\n\n    if (knownTypeNames[typeName]) {\n      context.reportError(\n        new GraphQLError(`There can be only one type named \"${typeName}\".`, {\n          nodes: [knownTypeNames[typeName], node.name],\n        }),\n      );\n    } else {\n      knownTypeNames[typeName] = node.name;\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isEnumType } from '../../type/definition.mjs';\n\n/**\n * Unique enum value names\n *\n * A GraphQL enum type is only valid if all its values are uniquely named.\n */\nexport function UniqueEnumValueNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownValueNames = Object.create(null);\n  return {\n    EnumTypeDefinition: checkValueUniqueness,\n    EnumTypeExtension: checkValueUniqueness,\n  };\n\n  function checkValueUniqueness(node) {\n    var _node$values;\n\n    const typeName = node.name.value;\n\n    if (!knownValueNames[typeName]) {\n      knownValueNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const valueNodes =\n      (_node$values = node.values) !== null && _node$values !== void 0\n        ? _node$values\n        : [];\n    const valueNames = knownValueNames[typeName];\n\n    for (const valueDef of valueNodes) {\n      const valueName = valueDef.name.value;\n      const existingType = existingTypeMap[typeName];\n\n      if (isEnumType(existingType) && existingType.getValue(valueName)) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: valueDef.name,\n            },\n          ),\n        );\n      } else if (valueNames[valueName]) {\n        context.reportError(\n          new GraphQLError(\n            `Enum value \"${typeName}.${valueName}\" can only be defined once.`,\n            {\n              nodes: [valueNames[valueName], valueDef.name],\n            },\n          ),\n        );\n      } else {\n        valueNames[valueName] = valueDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Unique field definition names\n *\n * A GraphQL complex type is only valid if all its fields are uniquely named.\n */\nexport function UniqueFieldDefinitionNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);\n  const knownFieldNames = Object.create(null);\n  return {\n    InputObjectTypeDefinition: checkFieldUniqueness,\n    InputObjectTypeExtension: checkFieldUniqueness,\n    InterfaceTypeDefinition: checkFieldUniqueness,\n    InterfaceTypeExtension: checkFieldUniqueness,\n    ObjectTypeDefinition: checkFieldUniqueness,\n    ObjectTypeExtension: checkFieldUniqueness,\n  };\n\n  function checkFieldUniqueness(node) {\n    var _node$fields;\n\n    const typeName = node.name.value;\n\n    if (!knownFieldNames[typeName]) {\n      knownFieldNames[typeName] = Object.create(null);\n    } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_node$fields = node.fields) !== null && _node$fields !== void 0\n        ? _node$fields\n        : [];\n    const fieldNames = knownFieldNames[typeName];\n\n    for (const fieldDef of fieldNodes) {\n      const fieldName = fieldDef.name.value;\n\n      if (hasField(existingTypeMap[typeName], fieldName)) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" already exists in the schema. It cannot also be defined in this type extension.`,\n            {\n              nodes: fieldDef.name,\n            },\n          ),\n        );\n      } else if (fieldNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `Field \"${typeName}.${fieldName}\" can only be defined once.`,\n            {\n              nodes: [fieldNames[fieldName], fieldDef.name],\n            },\n          ),\n        );\n      } else {\n        fieldNames[fieldName] = fieldDef.name;\n      }\n    }\n\n    return false;\n  }\n}\n\nfunction hasField(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    return type.getFields()[fieldName] != null;\n  }\n\n  return false;\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique directive names\n *\n * A GraphQL document is only valid if all defined directives have unique names.\n */\nexport function UniqueDirectiveNamesRule(context) {\n  const knownDirectiveNames = Object.create(null);\n  const schema = context.getSchema();\n  return {\n    DirectiveDefinition(node) {\n      const directiveName = node.name.value;\n\n      if (\n        schema !== null &&\n        schema !== void 0 &&\n        schema.getDirective(directiveName)\n      ) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${directiveName}\" already exists in the schema. It cannot be redefined.`,\n            {\n              nodes: node.name,\n            },\n          ),\n        );\n        return;\n      }\n\n      if (knownDirectiveNames[directiveName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one directive named \"@${directiveName}\".`,\n            {\n              nodes: [knownDirectiveNames[directiveName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownDirectiveNames[directiveName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { Kind } from './kinds.mjs';\nexport function isDefinitionNode(node) {\n  return (\n    isExecutableDefinitionNode(node) ||\n    isTypeSystemDefinitionNode(node) ||\n    isTypeSystemExtensionNode(node)\n  );\n}\nexport function isExecutableDefinitionNode(node) {\n  return (\n    node.kind === Kind.OPERATION_DEFINITION ||\n    node.kind === Kind.FRAGMENT_DEFINITION\n  );\n}\nexport function isSelectionNode(node) {\n  return (\n    node.kind === Kind.FIELD ||\n    node.kind === Kind.FRAGMENT_SPREAD ||\n    node.kind === Kind.INLINE_FRAGMENT\n  );\n}\nexport function isValueNode(node) {\n  return (\n    node.kind === Kind.VARIABLE ||\n    node.kind === Kind.INT ||\n    node.kind === Kind.FLOAT ||\n    node.kind === Kind.STRING ||\n    node.kind === Kind.BOOLEAN ||\n    node.kind === Kind.NULL ||\n    node.kind === Kind.ENUM ||\n    node.kind === Kind.LIST ||\n    node.kind === Kind.OBJECT\n  );\n}\nexport function isConstValueNode(node) {\n  return (\n    isValueNode(node) &&\n    (node.kind === Kind.LIST\n      ? node.values.some(isConstValueNode)\n      : node.kind === Kind.OBJECT\n      ? node.fields.some((field) => isConstValueNode(field.value))\n      : node.kind !== Kind.VARIABLE)\n  );\n}\nexport function isTypeNode(node) {\n  return (\n    node.kind === Kind.NAMED_TYPE ||\n    node.kind === Kind.LIST_TYPE ||\n    node.kind === Kind.NON_NULL_TYPE\n  );\n}\nexport function isTypeSystemDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCHEMA_DEFINITION ||\n    isTypeDefinitionNode(node) ||\n    node.kind === Kind.DIRECTIVE_DEFINITION\n  );\n}\nexport function isTypeDefinitionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_DEFINITION ||\n    node.kind === Kind.OBJECT_TYPE_DEFINITION ||\n    node.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n    node.kind === Kind.UNION_TYPE_DEFINITION ||\n    node.kind === Kind.ENUM_TYPE_DEFINITION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n  );\n}\nexport function isTypeSystemExtensionNode(node) {\n  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);\n}\nexport function isTypeExtensionNode(node) {\n  return (\n    node.kind === Kind.SCALAR_TYPE_EXTENSION ||\n    node.kind === Kind.OBJECT_TYPE_EXTENSION ||\n    node.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n    node.kind === Kind.UNION_TYPE_EXTENSION ||\n    node.kind === Kind.ENUM_TYPE_EXTENSION ||\n    node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION\n  );\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeSystemDefinitionNode,\n  isTypeSystemExtensionNode,\n} from '../../language/predicates.mjs';\nimport { introspectionTypes } from '../../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../../type/scalars.mjs';\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Spread-Type-Existence\n */\nexport function KnownTypeNamesRule(context) {\n  const schema = context.getSchema();\n  const existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  const typeNames = [\n    ...Object.keys(existingTypesMap),\n    ...Object.keys(definedTypes),\n  ];\n  return {\n    NamedType(node, _1, parent, _2, ancestors) {\n      const typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        const definitionNode =\n          (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0\n            ? _ancestors$\n            : parent;\n        const isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && standardTypeNames.includes(typeName)) {\n          return;\n        }\n\n        const suggestedTypes = suggestionList(\n          typeName,\n          isSDL ? standardTypeNames.concat(typeNames) : typeNames,\n        );\n        context.reportError(\n          new GraphQLError(\n            `Unknown type \"${typeName}\".` + didYouMean(suggestedTypes),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\nconst standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(\n  (type) => type.name,\n);\n\nfunction isSDLNode(value) {\n  return (\n    'kind' in value &&\n    (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value))\n  );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../../language/ast.mjs';\nimport { DirectiveLocation } from '../../language/directiveLocation.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known directives\n *\n * A GraphQL document is only valid if all `@directives` are known by the\n * schema and legally positioned.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Defined\n */\nexport function KnownDirectivesRule(context) {\n  const locationsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    locationsMap[directive.name] = directive.locations;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      locationsMap[def.name.value] = def.locations.map((name) => name.value);\n    }\n  }\n\n  return {\n    Directive(node, _key, _parent, _path, ancestors) {\n      const name = node.name.value;\n      const locations = locationsMap[name];\n\n      if (!locations) {\n        context.reportError(\n          new GraphQLError(`Unknown directive \"@${name}\".`, {\n            nodes: node,\n          }),\n        );\n        return;\n      }\n\n      const candidateLocation = getDirectiveLocationForASTPath(ancestors);\n\n      if (candidateLocation && !locations.includes(candidateLocation)) {\n        context.reportError(\n          new GraphQLError(\n            `Directive \"@${name}\" may not be used on ${candidateLocation}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getDirectiveLocationForASTPath(ancestors) {\n  const appliedTo = ancestors[ancestors.length - 1];\n  'kind' in appliedTo || invariant(false);\n\n  switch (appliedTo.kind) {\n    case Kind.OPERATION_DEFINITION:\n      return getDirectiveLocationForOperation(appliedTo.operation);\n\n    case Kind.FIELD:\n      return DirectiveLocation.FIELD;\n\n    case Kind.FRAGMENT_SPREAD:\n      return DirectiveLocation.FRAGMENT_SPREAD;\n\n    case Kind.INLINE_FRAGMENT:\n      return DirectiveLocation.INLINE_FRAGMENT;\n\n    case Kind.FRAGMENT_DEFINITION:\n      return DirectiveLocation.FRAGMENT_DEFINITION;\n\n    case Kind.VARIABLE_DEFINITION:\n      return DirectiveLocation.VARIABLE_DEFINITION;\n\n    case Kind.SCHEMA_DEFINITION:\n    case Kind.SCHEMA_EXTENSION:\n      return DirectiveLocation.SCHEMA;\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return DirectiveLocation.SCALAR;\n\n    case Kind.OBJECT_TYPE_DEFINITION:\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.OBJECT;\n\n    case Kind.FIELD_DEFINITION:\n      return DirectiveLocation.FIELD_DEFINITION;\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return DirectiveLocation.INTERFACE;\n\n    case Kind.UNION_TYPE_DEFINITION:\n    case Kind.UNION_TYPE_EXTENSION:\n      return DirectiveLocation.UNION;\n\n    case Kind.ENUM_TYPE_DEFINITION:\n    case Kind.ENUM_TYPE_EXTENSION:\n      return DirectiveLocation.ENUM;\n\n    case Kind.ENUM_VALUE_DEFINITION:\n      return DirectiveLocation.ENUM_VALUE;\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return DirectiveLocation.INPUT_OBJECT;\n\n    case Kind.INPUT_VALUE_DEFINITION: {\n      const parentNode = ancestors[ancestors.length - 3];\n      'kind' in parentNode || invariant(false);\n      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION\n        ? DirectiveLocation.INPUT_FIELD_DEFINITION\n        : DirectiveLocation.ARGUMENT_DEFINITION;\n    }\n    // Not reachable, all possible types have been considered.\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(appliedTo.kind));\n  }\n}\n\nfunction getDirectiveLocationForOperation(operation) {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return DirectiveLocation.QUERY;\n\n    case OperationTypeNode.MUTATION:\n      return DirectiveLocation.MUTATION;\n\n    case OperationTypeNode.SUBSCRIPTION:\n      return DirectiveLocation.SUBSCRIPTION;\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport {\n  isTypeDefinitionNode,\n  isTypeExtensionNode,\n} from '../../language/predicates.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Unique directive names per location\n *\n * A GraphQL document is only valid if all non-repeatable directives at\n * a given location are uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Directives-Are-Unique-Per-Location\n */\nexport function UniqueDirectivesPerLocationRule(context) {\n  const uniqueDirectiveMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      uniqueDirectiveMap[def.name.value] = !def.repeatable;\n    }\n  }\n\n  const schemaDirectives = Object.create(null);\n  const typeDirectivesMap = Object.create(null);\n  return {\n    // Many different AST nodes may contain directives. Rather than listing\n    // them all, just listen for entering any node, and check to see if it\n    // defines any directives.\n    enter(node) {\n      if (!('directives' in node) || !node.directives) {\n        return;\n      }\n\n      let seenDirectives;\n\n      if (\n        node.kind === Kind.SCHEMA_DEFINITION ||\n        node.kind === Kind.SCHEMA_EXTENSION\n      ) {\n        seenDirectives = schemaDirectives;\n      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {\n        const typeName = node.name.value;\n        seenDirectives = typeDirectivesMap[typeName];\n\n        if (seenDirectives === undefined) {\n          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);\n        }\n      } else {\n        seenDirectives = Object.create(null);\n      }\n\n      for (const directive of node.directives) {\n        const directiveName = directive.name.value;\n\n        if (uniqueDirectiveMap[directiveName]) {\n          if (seenDirectives[directiveName]) {\n            context.reportError(\n              new GraphQLError(\n                `The directive \"@${directiveName}\" can only be used once at this location.`,\n                {\n                  nodes: [seenDirectives[directiveName], directive],\n                },\n              ),\n            );\n          } else {\n            seenDirectives[directiveName] = directive;\n          }\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n","/**\n * Groups array items into a Map, given a function to produce grouping key.\n */\nexport function groupBy(list, keyFn) {\n  const result = new Map();\n\n  for (const item of list) {\n    const key = keyFn(item);\n    const group = result.get(key);\n\n    if (group === undefined) {\n      result.set(key, [item]);\n    } else {\n      group.push(item);\n    }\n  }\n\n  return result;\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument names\n *\n * A GraphQL field or directive is only valid if all supplied arguments are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n */\nexport function UniqueArgumentNamesRule(context) {\n  return {\n    Field: checkArgUniqueness,\n    Directive: checkArgUniqueness,\n  };\n\n  function checkArgUniqueness(parentNode) {\n    var _parentNode$arguments;\n\n    // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n    const argumentNodes =\n      (_parentNode$arguments = parentNode.arguments) !== null &&\n      _parentNode$arguments !== void 0\n        ? _parentNode$arguments\n        : [];\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one argument named \"${argName}\".`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n  }\n}\n","import { invariant } from '../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique input field names\n *\n * A GraphQL input object value is only valid if all supplied fields are\n * uniquely named.\n *\n * See https://spec.graphql.org/draft/#sec-Input-Object-Field-Uniqueness\n */\nexport function UniqueInputFieldNamesRule(context) {\n  const knownNameStack = [];\n  let knownNames = Object.create(null);\n  return {\n    ObjectValue: {\n      enter() {\n        knownNameStack.push(knownNames);\n        knownNames = Object.create(null);\n      },\n\n      leave() {\n        const prevKnownNames = knownNameStack.pop();\n        prevKnownNames || invariant(false);\n        knownNames = prevKnownNames;\n      },\n    },\n\n    ObjectField(node) {\n      const fieldName = node.name.value;\n\n      if (knownNames[fieldName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one input field named \"${fieldName}\".`,\n            {\n              nodes: [knownNames[fieldName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownNames[fieldName] = node.name;\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isExecutableDefinitionNode } from '../../language/predicates.mjs';\n\n/**\n * Executable definitions\n *\n * A GraphQL document is only valid for execution if all definitions are either\n * operation or fragment definitions.\n *\n * See https://spec.graphql.org/draft/#sec-Executable-Definitions\n */\nexport function ExecutableDefinitionsRule(context) {\n  return {\n    Document(node) {\n      for (const definition of node.definitions) {\n        if (!isExecutableDefinitionNode(definition)) {\n          const defName =\n            definition.kind === Kind.SCHEMA_DEFINITION ||\n            definition.kind === Kind.SCHEMA_EXTENSION\n              ? 'schema'\n              : '\"' + definition.name.value + '\"';\n          context.reportError(\n            new GraphQLError(`The ${defName} definition is not executable.`, {\n              nodes: definition,\n            }),\n          );\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Known argument names\n *\n * A GraphQL field is only valid if all supplied arguments are defined by\n * that field.\n *\n * See https://spec.graphql.org/draft/#sec-Argument-Names\n * See https://spec.graphql.org/draft/#sec-Directives-Are-In-Valid-Locations\n */\nexport function KnownArgumentNamesRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...KnownArgumentNamesOnDirectivesRule(context),\n\n    Argument(argNode) {\n      const argDef = context.getArgument();\n      const fieldDef = context.getFieldDef();\n      const parentType = context.getParentType();\n\n      if (!argDef && fieldDef && parentType) {\n        const argName = argNode.name.value;\n        const knownArgsNames = fieldDef.args.map((arg) => arg.name);\n        const suggestions = suggestionList(argName, knownArgsNames);\n        context.reportError(\n          new GraphQLError(\n            `Unknown argument \"${argName}\" on field \"${parentType.name}.${fieldDef.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: argNode,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function KnownArgumentNamesOnDirectivesRule(context) {\n  const directiveArgs = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives = schema\n    ? schema.getDirectives()\n    : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argsNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);\n    }\n  }\n\n  return {\n    Directive(directiveNode) {\n      const directiveName = directiveNode.name.value;\n      const knownArgs = directiveArgs[directiveName];\n\n      if (directiveNode.arguments && knownArgs) {\n        for (const argNode of directiveNode.arguments) {\n          const argName = argNode.name.value;\n\n          if (!knownArgs.includes(argName)) {\n            const suggestions = suggestionList(argName, knownArgs);\n            context.reportError(\n              new GraphQLError(\n                `Unknown argument \"${argName}\" on directive \"@${directiveName}\".` +\n                  didYouMean(suggestions),\n                {\n                  nodes: argNode,\n                },\n              ),\n            );\n          }\n        }\n      }\n\n      return false;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Known fragment names\n *\n * A GraphQL document is only valid if all `...Fragment` fragment spreads refer\n * to fragments defined in the same document.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spread-target-defined\n */\nexport function KnownFragmentNamesRule(context) {\n  return {\n    FragmentSpread(node) {\n      const fragmentName = node.name.value;\n      const fragment = context.getFragment(fragmentName);\n\n      if (!fragment) {\n        context.reportError(\n          new GraphQLError(`Unknown fragment \"${fragmentName}\".`, {\n            nodes: node.name,\n          }),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused fragments\n *\n * A GraphQL document is only valid if all fragment definitions are spread\n * within operations, or spread within other fragments spread within operations.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-Must-Be-Used\n */\nexport function NoUnusedFragmentsRule(context) {\n  const operationDefs = [];\n  const fragmentDefs = [];\n  return {\n    OperationDefinition(node) {\n      operationDefs.push(node);\n      return false;\n    },\n\n    FragmentDefinition(node) {\n      fragmentDefs.push(node);\n      return false;\n    },\n\n    Document: {\n      leave() {\n        const fragmentNameUsed = Object.create(null);\n\n        for (const operation of operationDefs) {\n          for (const fragment of context.getRecursivelyReferencedFragments(\n            operation,\n          )) {\n            fragmentNameUsed[fragment.name.value] = true;\n          }\n        }\n\n        for (const fragmentDef of fragmentDefs) {\n          const fragName = fragmentDef.name.value;\n\n          if (fragmentNameUsed[fragName] !== true) {\n            context.reportError(\n              new GraphQLError(`Fragment \"${fragName}\" is never used.`, {\n                nodes: fragmentDef,\n              }),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n","import { naturalCompare } from '../jsutils/naturalCompare.mjs';\nimport { Kind } from '../language/kinds.mjs';\n/**\n * Sort ValueNode.\n *\n * This function returns a sorted copy of the given ValueNode.\n *\n * @internal\n */\n\nexport function sortValueNode(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.OBJECT:\n      return { ...valueNode, fields: sortFields(valueNode.fields) };\n\n    case Kind.LIST:\n      return { ...valueNode, values: valueNode.values.map(sortValueNode) };\n\n    case Kind.INT:\n    case Kind.FLOAT:\n    case Kind.STRING:\n    case Kind.BOOLEAN:\n    case Kind.NULL:\n    case Kind.ENUM:\n    case Kind.VARIABLE:\n      return valueNode;\n  }\n}\n\nfunction sortFields(fields) {\n  return fields\n    .map((fieldNode) => ({\n      ...fieldNode,\n      value: sortValueNode(fieldNode.value),\n    }))\n    .sort((fieldA, fieldB) =>\n      naturalCompare(fieldA.name.value, fieldB.name.value),\n    );\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n\n  return reason;\n}\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            {\n              nodes: fields1.concat(fields2),\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentType,\n  selectionSet,\n) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet,\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentNames[i],\n      ); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentNames,\n          comparedFragmentPairs,\n          false,\n          fragmentNames[i],\n          fragmentNames[j],\n        );\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\nfunction collectConflictsBetweenFieldsAndFragment(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fieldMap,\n  fragmentName,\n) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment,\n    ); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2,\n  ); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (\n      comparedFragmentPairs.has(\n        referencedFragmentName,\n        fragmentName,\n        areMutuallyExclusive,\n      )\n    ) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(\n      referencedFragmentName,\n      fragmentName,\n      areMutuallyExclusive,\n    );\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentName,\n    );\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\nfunction collectConflictsBetweenFragments(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  fragmentName1,\n  fragmentName2,\n) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n  if (\n    comparedFragmentPairs.has(\n      fragmentName1,\n      fragmentName2,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment1,\n    );\n  const [fieldMap2, referencedFragmentNames2] =\n    getReferencedFieldsAndFragmentNames(\n      context,\n      cachedFieldsAndFragmentNames,\n      fragment2,\n    ); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentName1,\n      referencedFragmentName2,\n    );\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentName1,\n      fragmentName2,\n    );\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\nfunction findConflictsBetweenSubSelectionSets(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  areMutuallyExclusive,\n  parentType1,\n  selectionSet1,\n  parentType2,\n  selectionSet2,\n) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1,\n  );\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2,\n  ); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2,\n  ); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentName2,\n    );\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentName1,\n    );\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentName1,\n        fragmentName2,\n      );\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\nfunction collectConflictsWithin(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  fieldMap,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j],\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\nfunction collectConflictsBetween(\n  context,\n  conflicts,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  fieldMap1,\n  fieldMap2,\n) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            field2,\n          );\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\nfunction findConflict(\n  context,\n  cachedFieldsAndFragmentNames,\n  comparedFragmentPairs,\n  parentFieldsAreMutuallyExclusive,\n  responseName,\n  field1,\n  field2,\n) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    } // Two field calls must have the same arguments.\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  } // The return type for each field.\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments;\n\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\n  const args =\n    /* c8 ignore next */\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\n    _fieldNode$arguments !== void 0\n      ? _fieldNode$arguments\n      : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map((argNode) => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value,\n    })),\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\nfunction getFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  parentType,\n  selectionSet,\n) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentNames,\n  );\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\nfunction getReferencedFieldsAndFragmentNames(\n  context,\n  cachedFieldsAndFragmentNames,\n  fragment,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragmentType,\n    fragment.selectionSet,\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context,\n  parentType,\n  selectionSet,\n  nodeAndDefs,\n  fragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        if (!nodeAndDefs[responseName]) {\n          nodeAndDefs[responseName] = [];\n        }\n\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n\n        _collectFieldsAndFragmentNames(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentNames,\n        );\n\n        break;\n      }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n/**\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\n */\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result =\n      (_this$_data$get = this._data.get(key1)) === null ||\n      _this$_data$get === void 0\n        ? void 0\n        : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isRequiredArgument, isType } from '../../type/definition.mjs';\nimport { specifiedDirectives } from '../../type/directives.mjs';\n\n/**\n * Provided required arguments\n *\n * A field or directive is only valid if all required (non-null without a\n * default value) field arguments have been provided.\n */\nexport function ProvidedRequiredArgumentsRule(context) {\n  return {\n    // eslint-disable-next-line new-cap\n    ...ProvidedRequiredArgumentsOnDirectivesRule(context),\n    Field: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(fieldNode) {\n        var _fieldNode$arguments;\n\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          return false;\n        }\n\n        const providedArgs = new Set( // FIXME: https://github.com/graphql/graphql-js/issues/2203\n          /* c8 ignore next */\n          (_fieldNode$arguments = fieldNode.arguments) === null ||\n          _fieldNode$arguments === void 0\n            ? void 0\n            : _fieldNode$arguments.map((arg) => arg.name.value),\n        );\n\n        for (const argDef of fieldDef.args) {\n          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {\n            const argTypeStr = inspect(argDef.type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldDef.name}\" argument \"${argDef.name}\" of type \"${argTypeStr}\" is required, but it was not provided.`,\n                {\n                  nodes: fieldNode,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n  };\n}\n/**\n * @internal\n */\n\nexport function ProvidedRequiredArgumentsOnDirectivesRule(context) {\n  var _schema$getDirectives;\n\n  const requiredArgsMap = Object.create(null);\n  const schema = context.getSchema();\n  const definedDirectives =\n    (_schema$getDirectives =\n      schema === null || schema === void 0\n        ? void 0\n        : schema.getDirectives()) !== null && _schema$getDirectives !== void 0\n      ? _schema$getDirectives\n      : specifiedDirectives;\n\n  for (const directive of definedDirectives) {\n    requiredArgsMap[directive.name] = keyMap(\n      directive.args.filter(isRequiredArgument),\n      (arg) => arg.name,\n    );\n  }\n\n  const astDefinitions = context.getDocument().definitions;\n\n  for (const def of astDefinitions) {\n    if (def.kind === Kind.DIRECTIVE_DEFINITION) {\n      var _def$arguments;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argNodes =\n        (_def$arguments = def.arguments) !== null && _def$arguments !== void 0\n          ? _def$arguments\n          : [];\n      requiredArgsMap[def.name.value] = keyMap(\n        argNodes.filter(isRequiredArgumentNode),\n        (arg) => arg.name.value,\n      );\n    }\n  }\n\n  return {\n    Directive: {\n      // Validate on leave to allow for deeper errors to appear first.\n      leave(directiveNode) {\n        const directiveName = directiveNode.name.value;\n        const requiredArgs = requiredArgsMap[directiveName];\n\n        if (requiredArgs) {\n          var _directiveNode$argume;\n\n          // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n          /* c8 ignore next */\n          const argNodes =\n            (_directiveNode$argume = directiveNode.arguments) !== null &&\n            _directiveNode$argume !== void 0\n              ? _directiveNode$argume\n              : [];\n          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));\n\n          for (const [argName, argDef] of Object.entries(requiredArgs)) {\n            if (!argNodeMap.has(argName)) {\n              const argType = isType(argDef.type)\n                ? inspect(argDef.type)\n                : print(argDef.type);\n              context.reportError(\n                new GraphQLError(\n                  `Directive \"@${directiveName}\" argument \"${argName}\" of type \"${argType}\" is required, but it was not provided.`,\n                  {\n                    nodes: directiveNode,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n  };\n}\n\nfunction isRequiredArgumentNode(arg) {\n  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;\n}\n","import { inspect } from '../jsutils/inspect.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { printPathArray } from '../jsutils/printPathArray.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { print } from '../language/printer.mjs';\nimport { isInputType, isNonNullType } from '../type/definition.mjs';\nimport { coerceInputValue } from '../utilities/coerceInputValue.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { valueFromAST } from '../utilities/valueFromAST.mjs';\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(schema, varDefNodes, inputs, options) {\n  const errors = [];\n  const maxErrors =\n    options === null || options === void 0 ? void 0 : options.maxErrors;\n\n  try {\n    const coerced = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n\n        errors.push(error);\n      },\n    );\n\n    if (errors.length === 0) {\n      return {\n        coerced,\n      };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return {\n    errors,\n  };\n}\n\nfunction coerceVariableValues(schema, varDefNodes, inputs, onError) {\n  const coercedValues = {};\n\n  for (const varDefNode of varDefNodes) {\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type);\n\n    if (!isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      const varTypeStr = print(varDefNode.type);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" expected value of type \"${varTypeStr}\" which cannot be used as an input type.`,\n          {\n            nodes: varDefNode.type,\n          },\n        ),\n      );\n      continue;\n    }\n\n    if (!hasOwnProperty(inputs, varName)) {\n      if (varDefNode.defaultValue) {\n        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);\n      } else if (isNonNullType(varType)) {\n        const varTypeStr = inspect(varType);\n        onError(\n          new GraphQLError(\n            `Variable \"$${varName}\" of required type \"${varTypeStr}\" was not provided.`,\n            {\n              nodes: varDefNode,\n            },\n          ),\n        );\n      }\n\n      continue;\n    }\n\n    const value = inputs[varName];\n\n    if (value === null && isNonNullType(varType)) {\n      const varTypeStr = inspect(varType);\n      onError(\n        new GraphQLError(\n          `Variable \"$${varName}\" of non-null type \"${varTypeStr}\" must not be null.`,\n          {\n            nodes: varDefNode,\n          },\n        ),\n      );\n      continue;\n    }\n\n    coercedValues[varName] = coerceInputValue(\n      value,\n      varType,\n      (path, invalidValue, error) => {\n        let prefix =\n          `Variable \"$${varName}\" got invalid value ` + inspect(invalidValue);\n\n        if (path.length > 0) {\n          prefix += ` at \"${varName}${printPathArray(path)}\"`;\n        }\n\n        onError(\n          new GraphQLError(prefix + '; ' + error.message, {\n            nodes: varDefNode,\n            originalError: error.originalError,\n          }),\n        );\n      },\n    );\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getArgumentValues(def, node, variableValues) {\n  var _node$arguments;\n\n  const coercedValues = {}; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n  const argumentNodes =\n    (_node$arguments = node.arguments) !== null && _node$arguments !== void 0\n      ? _node$arguments\n      : [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          {\n            nodes: node,\n          },\n        );\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (\n        variableValues == null ||\n        !hasOwnProperty(variableValues, variableName)\n      ) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            {\n              nodes: valueNode,\n            },\n          );\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        {\n          nodes: valueNode,\n        },\n      );\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\nexport function getDirectiveValues(directiveDef, node, variableValues) {\n  var _node$directives;\n\n  const directiveNode =\n    (_node$directives = node.directives) === null || _node$directives === void 0\n      ? void 0\n      : _node$directives.find(\n          (directive) => directive.name.value === directiveDef.name,\n        );\n\n  if (directiveNode) {\n    return getArgumentValues(directiveDef, directiveNode, variableValues);\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { isAbstractType } from '../type/definition.mjs';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.mjs';\nimport { typeFromAST } from '../utilities/typeFromAST.mjs';\nimport { getDirectiveValues } from './values.mjs';\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectFields(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n) {\n  const fields = new Map();\n  collectFieldsImpl(\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    selectionSet,\n    fields,\n    new Set(),\n  );\n  return fields;\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n\nexport function collectSubfields(\n  schema,\n  fragments,\n  variableValues,\n  returnType,\n  fieldNodes,\n) {\n  const subFieldNodes = new Map();\n  const visitedFragmentNames = new Set();\n\n  for (const node of fieldNodes) {\n    if (node.selectionSet) {\n      collectFieldsImpl(\n        schema,\n        fragments,\n        variableValues,\n        returnType,\n        node.selectionSet,\n        subFieldNodes,\n        visitedFragmentNames,\n      );\n    }\n  }\n\n  return subFieldNodes;\n}\n\nfunction collectFieldsImpl(\n  schema,\n  fragments,\n  variableValues,\n  runtimeType,\n  selectionSet,\n  fields,\n  visitedFragmentNames,\n) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(variableValues, selection)) {\n          continue;\n        }\n\n        const name = getFieldEntryKey(selection);\n        const fieldList = fields.get(name);\n\n        if (fieldList !== undefined) {\n          fieldList.push(selection);\n        } else {\n          fields.set(name, [selection]);\n        }\n\n        break;\n      }\n\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(variableValues, selection) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(variableValues, selection)\n        ) {\n          continue;\n        }\n\n        visitedFragmentNames.add(fragName);\n        const fragment = fragments[fragName];\n\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(schema, fragment, runtimeType)\n        ) {\n          continue;\n        }\n\n        collectFieldsImpl(\n          schema,\n          fragments,\n          variableValues,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\n\nfunction shouldIncludeNode(variableValues, node) {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    variableValues,\n  );\n\n  if (\n    (include === null || include === void 0 ? void 0 : include.if) === false\n  ) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\nfunction doesFragmentConditionMatch(schema, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\nfunction getFieldEntryKey(node) {\n  return node.alias ? node.alias.value : node.name.value;\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { keyMap } from '../../jsutils/keyMap.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport {\n  getNamedType,\n  getNullableType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../../type/definition.mjs';\n\n/**\n * Value literals of correct type\n *\n * A GraphQL document is only valid if all value literals are of the type\n * expected at their position.\n *\n * See https://spec.graphql.org/draft/#sec-Values-of-Correct-Type\n */\nexport function ValuesOfCorrectTypeRule(context) {\n  return {\n    ListValue(node) {\n      // Note: TypeInfo will traverse into a list's item type, so look to the\n      // parent input type to check if it is a list.\n      const type = getNullableType(context.getParentInputType());\n\n      if (!isListType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      }\n    },\n\n    ObjectValue(node) {\n      const type = getNamedType(context.getInputType());\n\n      if (!isInputObjectType(type)) {\n        isValidValueNode(context, node);\n        return false; // Don't traverse further.\n      } // Ensure every required field exists.\n\n      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);\n\n      for (const fieldDef of Object.values(type.getFields())) {\n        const fieldNode = fieldNodeMap[fieldDef.name];\n\n        if (!fieldNode && isRequiredInputField(fieldDef)) {\n          const typeStr = inspect(fieldDef.type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${type.name}.${fieldDef.name}\" of required type \"${typeStr}\" was not provided.`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const parentType = getNamedType(context.getParentInputType());\n      const fieldType = context.getInputType();\n\n      if (!fieldType && isInputObjectType(parentType)) {\n        const suggestions = suggestionList(\n          node.name.value,\n          Object.keys(parentType.getFields()),\n        );\n        context.reportError(\n          new GraphQLError(\n            `Field \"${node.name.value}\" is not defined by type \"${parentType.name}\".` +\n              didYouMean(suggestions),\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    NullValue(node) {\n      const type = context.getInputType();\n\n      if (isNonNullType(type)) {\n        context.reportError(\n          new GraphQLError(\n            `Expected value of type \"${inspect(type)}\", found ${print(node)}.`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    EnumValue: (node) => isValidValueNode(context, node),\n    IntValue: (node) => isValidValueNode(context, node),\n    FloatValue: (node) => isValidValueNode(context, node),\n    StringValue: (node) => isValidValueNode(context, node),\n    BooleanValue: (node) => isValidValueNode(context, node),\n  };\n}\n/**\n * Any value literal may be a valid representation of a Scalar, depending on\n * that scalar type.\n */\n\nfunction isValidValueNode(context, node) {\n  // Report any error at the full type expected by the location.\n  const locationType = context.getInputType();\n\n  if (!locationType) {\n    return;\n  }\n\n  const type = getNamedType(locationType);\n\n  if (!isLeafType(type)) {\n    const typeStr = inspect(locationType);\n    context.reportError(\n      new GraphQLError(\n        `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n        {\n          nodes: node,\n        },\n      ),\n    );\n    return;\n  } // Scalars and Enums determine if a literal value is valid via parseLiteral(),\n  // which may throw or return an invalid value to indicate failure.\n\n  try {\n    const parseResult = type.parseLiteral(\n      node,\n      undefined,\n      /* variables */\n    );\n\n    if (parseResult === undefined) {\n      const typeStr = inspect(locationType);\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}.`,\n          {\n            nodes: node,\n          },\n        ),\n      );\n    }\n  } catch (error) {\n    const typeStr = inspect(locationType);\n\n    if (error instanceof GraphQLError) {\n      context.reportError(error);\n    } else {\n      context.reportError(\n        new GraphQLError(\n          `Expected value of type \"${typeStr}\", found ${print(node)}; ` +\n            error.message,\n          {\n            nodes: node,\n            originalError: error,\n          },\n        ),\n      );\n    }\n  }\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isNonNullType } from '../../type/definition.mjs';\nimport { isTypeSubTypeOf } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables in allowed position\n *\n * Variable usages must be compatible with the arguments they are passed to.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Usages-are-Allowed\n */\nexport function VariablesInAllowedPositionRule(context) {\n  let varDefMap = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        varDefMap = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node, type, defaultValue } of usages) {\n          const varName = node.name.value;\n          const varDef = varDefMap[varName];\n\n          if (varDef && type) {\n            // A var type is allowed if it is the same or more strict (e.g. is\n            // a subtype of) than the expected type. It can be more strict if\n            // the variable type is non-null when the expected type is nullable.\n            // If both are list types, the variable item type can be more strict\n            // than the expected item type (contravariant).\n            const schema = context.getSchema();\n            const varType = typeFromAST(schema, varDef.type);\n\n            if (\n              varType &&\n              !allowedVariableUsage(\n                schema,\n                varType,\n                varDef.defaultValue,\n                type,\n                defaultValue,\n              )\n            ) {\n              const varTypeStr = inspect(varType);\n              const typeStr = inspect(type);\n              context.reportError(\n                new GraphQLError(\n                  `Variable \"$${varName}\" of type \"${varTypeStr}\" used in position expecting type \"${typeStr}\".`,\n                  {\n                    nodes: [varDef, node],\n                  },\n                ),\n              );\n            }\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      varDefMap[node.variable.name.value] = node;\n    },\n  };\n}\n/**\n * Returns true if the variable is allowed in the location it was found,\n * which includes considering if default values exist for either the variable\n * or the location at which it is located.\n */\n\nfunction allowedVariableUsage(\n  schema,\n  varType,\n  varDefaultValue,\n  locationType,\n  locationDefaultValue,\n) {\n  if (isNonNullType(locationType) && !isNonNullType(varType)) {\n    const hasNonNullVariableDefaultValue =\n      varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;\n    const hasLocationDefaultValue = locationDefaultValue !== undefined;\n\n    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {\n      return false;\n    }\n\n    const nullableLocationType = locationType.ofType;\n    return isTypeSubTypeOf(schema, varType, nullableLocationType);\n  }\n\n  return isTypeSubTypeOf(schema, varType, locationType);\n}\n","// Spec Section: \"Executable Definitions\"\nimport { ExecutableDefinitionsRule } from './rules/ExecutableDefinitionsRule.mjs'; // Spec Section: \"Field Selections on Objects, Interfaces, and Unions Types\"\n\nimport { FieldsOnCorrectTypeRule } from './rules/FieldsOnCorrectTypeRule.mjs'; // Spec Section: \"Fragments on Composite Types\"\n\nimport { FragmentsOnCompositeTypesRule } from './rules/FragmentsOnCompositeTypesRule.mjs'; // Spec Section: \"Argument Names\"\n\nimport {\n  KnownArgumentNamesOnDirectivesRule,\n  KnownArgumentNamesRule,\n} from './rules/KnownArgumentNamesRule.mjs'; // Spec Section: \"Directives Are Defined\"\n\nimport { KnownDirectivesRule } from './rules/KnownDirectivesRule.mjs'; // Spec Section: \"Fragment spread target defined\"\n\nimport { KnownFragmentNamesRule } from './rules/KnownFragmentNamesRule.mjs'; // Spec Section: \"Fragment Spread Type Existence\"\n\nimport { KnownTypeNamesRule } from './rules/KnownTypeNamesRule.mjs'; // Spec Section: \"Lone Anonymous Operation\"\n\nimport { LoneAnonymousOperationRule } from './rules/LoneAnonymousOperationRule.mjs'; // SDL-specific validation rules\n\nimport { LoneSchemaDefinitionRule } from './rules/LoneSchemaDefinitionRule.mjs'; // Spec Section: \"Fragments must not form cycles\"\n\nimport { NoFragmentCyclesRule } from './rules/NoFragmentCyclesRule.mjs'; // Spec Section: \"All Variable Used Defined\"\n\nimport { NoUndefinedVariablesRule } from './rules/NoUndefinedVariablesRule.mjs'; // Spec Section: \"Fragments must be used\"\n\nimport { NoUnusedFragmentsRule } from './rules/NoUnusedFragmentsRule.mjs'; // Spec Section: \"All Variables Used\"\n\nimport { NoUnusedVariablesRule } from './rules/NoUnusedVariablesRule.mjs'; // Spec Section: \"Field Selection Merging\"\n\nimport { OverlappingFieldsCanBeMergedRule } from './rules/OverlappingFieldsCanBeMergedRule.mjs'; // Spec Section: \"Fragment spread is possible\"\n\nimport { PossibleFragmentSpreadsRule } from './rules/PossibleFragmentSpreadsRule.mjs';\nimport { PossibleTypeExtensionsRule } from './rules/PossibleTypeExtensionsRule.mjs'; // Spec Section: \"Argument Optionality\"\n\nimport {\n  ProvidedRequiredArgumentsOnDirectivesRule,\n  ProvidedRequiredArgumentsRule,\n} from './rules/ProvidedRequiredArgumentsRule.mjs'; // Spec Section: \"Leaf Field Selections\"\n\nimport { ScalarLeafsRule } from './rules/ScalarLeafsRule.mjs'; // Spec Section: \"Subscriptions with Single Root Field\"\n\nimport { SingleFieldSubscriptionsRule } from './rules/SingleFieldSubscriptionsRule.mjs';\nimport { UniqueArgumentDefinitionNamesRule } from './rules/UniqueArgumentDefinitionNamesRule.mjs'; // Spec Section: \"Argument Uniqueness\"\n\nimport { UniqueArgumentNamesRule } from './rules/UniqueArgumentNamesRule.mjs';\nimport { UniqueDirectiveNamesRule } from './rules/UniqueDirectiveNamesRule.mjs'; // Spec Section: \"Directives Are Unique Per Location\"\n\nimport { UniqueDirectivesPerLocationRule } from './rules/UniqueDirectivesPerLocationRule.mjs';\nimport { UniqueEnumValueNamesRule } from './rules/UniqueEnumValueNamesRule.mjs';\nimport { UniqueFieldDefinitionNamesRule } from './rules/UniqueFieldDefinitionNamesRule.mjs'; // Spec Section: \"Fragment Name Uniqueness\"\n\nimport { UniqueFragmentNamesRule } from './rules/UniqueFragmentNamesRule.mjs'; // Spec Section: \"Input Object Field Uniqueness\"\n\nimport { UniqueInputFieldNamesRule } from './rules/UniqueInputFieldNamesRule.mjs'; // Spec Section: \"Operation Name Uniqueness\"\n\nimport { UniqueOperationNamesRule } from './rules/UniqueOperationNamesRule.mjs';\nimport { UniqueOperationTypesRule } from './rules/UniqueOperationTypesRule.mjs';\nimport { UniqueTypeNamesRule } from './rules/UniqueTypeNamesRule.mjs'; // Spec Section: \"Variable Uniqueness\"\n\nimport { UniqueVariableNamesRule } from './rules/UniqueVariableNamesRule.mjs'; // Spec Section: \"Value Type Correctness\"\n\nimport { ValuesOfCorrectTypeRule } from './rules/ValuesOfCorrectTypeRule.mjs'; // Spec Section: \"Variables are Input Types\"\n\nimport { VariablesAreInputTypesRule } from './rules/VariablesAreInputTypesRule.mjs'; // Spec Section: \"All Variable Usages Are Allowed\"\n\nimport { VariablesInAllowedPositionRule } from './rules/VariablesInAllowedPositionRule.mjs';\n\n/**\n * This set includes all validation rules defined by the GraphQL spec.\n *\n * The order of the rules in this list has been adjusted to lead to the\n * most clear output when encountering multiple validation errors.\n */\nexport const specifiedRules = Object.freeze([\n  ExecutableDefinitionsRule,\n  UniqueOperationNamesRule,\n  LoneAnonymousOperationRule,\n  SingleFieldSubscriptionsRule,\n  KnownTypeNamesRule,\n  FragmentsOnCompositeTypesRule,\n  VariablesAreInputTypesRule,\n  ScalarLeafsRule,\n  FieldsOnCorrectTypeRule,\n  UniqueFragmentNamesRule,\n  KnownFragmentNamesRule,\n  NoUnusedFragmentsRule,\n  PossibleFragmentSpreadsRule,\n  NoFragmentCyclesRule,\n  UniqueVariableNamesRule,\n  NoUndefinedVariablesRule,\n  NoUnusedVariablesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  KnownArgumentNamesRule,\n  UniqueArgumentNamesRule,\n  ValuesOfCorrectTypeRule,\n  ProvidedRequiredArgumentsRule,\n  VariablesInAllowedPositionRule,\n  OverlappingFieldsCanBeMergedRule,\n  UniqueInputFieldNamesRule,\n]);\n/**\n * @internal\n */\n\nexport const specifiedSDLRules = Object.freeze([\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueArgumentDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  KnownArgumentNamesOnDirectivesRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule,\n  ProvidedRequiredArgumentsOnDirectivesRule,\n]);\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique operation names\n *\n * A GraphQL document is only valid if all defined operations have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Operation-Name-Uniqueness\n */\nexport function UniqueOperationNamesRule(context) {\n  const knownOperationNames = Object.create(null);\n  return {\n    OperationDefinition(node) {\n      const operationName = node.name;\n\n      if (operationName) {\n        if (knownOperationNames[operationName.value]) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one operation named \"${operationName.value}\".`,\n              {\n                nodes: [\n                  knownOperationNames[operationName.value],\n                  operationName,\n                ],\n              },\n            ),\n          );\n        } else {\n          knownOperationNames[operationName.value] = operationName;\n        }\n      }\n\n      return false;\n    },\n\n    FragmentDefinition: () => false,\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\n\n/**\n * Lone anonymous operation\n *\n * A GraphQL document is only valid if when it contains an anonymous operation\n * (the query short-hand) that it contains only that one operation definition.\n *\n * See https://spec.graphql.org/draft/#sec-Lone-Anonymous-Operation\n */\nexport function LoneAnonymousOperationRule(context) {\n  let operationCount = 0;\n  return {\n    Document(node) {\n      operationCount = node.definitions.filter(\n        (definition) => definition.kind === Kind.OPERATION_DEFINITION,\n      ).length;\n    },\n\n    OperationDefinition(node) {\n      if (!node.name && operationCount > 1) {\n        context.reportError(\n          new GraphQLError(\n            'This anonymous operation must be the only defined operation.',\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { collectFields } from '../../execution/collectFields.mjs';\n\n/**\n * Subscriptions must only include a non-introspection field.\n *\n * A GraphQL subscription is valid only if it contains a single root field and\n * that root field is not an introspection field.\n *\n * See https://spec.graphql.org/draft/#sec-Single-root-field\n */\nexport function SingleFieldSubscriptionsRule(context) {\n  return {\n    OperationDefinition(node) {\n      if (node.operation === 'subscription') {\n        const schema = context.getSchema();\n        const subscriptionType = schema.getSubscriptionType();\n\n        if (subscriptionType) {\n          const operationName = node.name ? node.name.value : null;\n          const variableValues = Object.create(null);\n          const document = context.getDocument();\n          const fragments = Object.create(null);\n\n          for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n              fragments[definition.name.value] = definition;\n            }\n          }\n\n          const fields = collectFields(\n            schema,\n            fragments,\n            variableValues,\n            subscriptionType,\n            node.selectionSet,\n          );\n\n          if (fields.size > 1) {\n            const fieldSelectionLists = [...fields.values()];\n            const extraFieldSelectionLists = fieldSelectionLists.slice(1);\n            const extraFieldSelections = extraFieldSelectionLists.flat();\n            context.reportError(\n              new GraphQLError(\n                operationName != null\n                  ? `Subscription \"${operationName}\" must select only one top level field.`\n                  : 'Anonymous Subscription must select only one top level field.',\n                {\n                  nodes: extraFieldSelections,\n                },\n              ),\n            );\n          }\n\n          for (const fieldNodes of fields.values()) {\n            const field = fieldNodes[0];\n            const fieldName = field.name.value;\n\n            if (fieldName.startsWith('__')) {\n              context.reportError(\n                new GraphQLError(\n                  operationName != null\n                    ? `Subscription \"${operationName}\" must not select an introspection top level field.`\n                    : 'Anonymous Subscription must not select an introspection top level field.',\n                  {\n                    nodes: fieldNodes,\n                  },\n                ),\n              );\n            }\n          }\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(context) {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              {\n                nodes: typeCondition,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            {\n              nodes: node.typeCondition,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { isInputType } from '../../type/definition.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Variables are input types\n *\n * A GraphQL operation is only valid if all the variables it defines are of\n * input types (scalar, enum, or input object).\n *\n * See https://spec.graphql.org/draft/#sec-Variables-Are-Input-Types\n */\nexport function VariablesAreInputTypesRule(context) {\n  return {\n    VariableDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.type);\n\n      if (type !== undefined && !isInputType(type)) {\n        const variableName = node.variable.name.value;\n        const typeName = print(node.type);\n        context.reportError(\n          new GraphQLError(\n            `Variable \"$${variableName}\" cannot be non-input type \"${typeName}\".`,\n            {\n              nodes: node.type,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { getNamedType, isLeafType } from '../../type/definition.mjs';\n\n/**\n * Scalar leafs\n *\n * A GraphQL document is valid only if all leaf fields (fields without\n * sub selections) are of scalar or enum types.\n */\nexport function ScalarLeafsRule(context) {\n  return {\n    Field(node) {\n      const type = context.getType();\n      const selectionSet = node.selectionSet;\n\n      if (type) {\n        if (isLeafType(getNamedType(type))) {\n          if (selectionSet) {\n            const fieldName = node.name.value;\n            const typeStr = inspect(type);\n            context.reportError(\n              new GraphQLError(\n                `Field \"${fieldName}\" must not have a selection since type \"${typeStr}\" has no subfields.`,\n                {\n                  nodes: selectionSet,\n                },\n              ),\n            );\n          }\n        } else if (!selectionSet) {\n          const fieldName = node.name.value;\n          const typeStr = inspect(type);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${fieldName}\" of type \"${typeStr}\" must have a selection of subfields. Did you mean \"${fieldName} { ... }\"?`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { naturalCompare } from '../../jsutils/naturalCompare.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.mjs';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field(node) {\n      const type = context.getParentType();\n\n      if (type) {\n        const fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            getSuggestedTypeNames(schema, type, fieldName),\n          ); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type.name}\".` +\n                suggestion,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set();\n  const usageCount = Object.create(null);\n\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      var _usageCount$possibleI;\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        ((_usageCount$possibleI = usageCount[possibleInterface.name]) !==\n          null && _usageCount$possibleI !== void 0\n          ? _usageCount$possibleI\n          : 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      } // Suggest super types first followed by subtypes\n\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n  return [];\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique fragment names\n *\n * A GraphQL document is only valid if all defined fragments have unique names.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-Name-Uniqueness\n */\nexport function UniqueFragmentNamesRule(context) {\n  const knownFragmentNames = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      const fragmentName = node.name.value;\n\n      if (knownFragmentNames[fragmentName]) {\n        context.reportError(\n          new GraphQLError(\n            `There can be only one fragment named \"${fragmentName}\".`,\n            {\n              nodes: [knownFragmentNames[fragmentName], node.name],\n            },\n          ),\n        );\n      } else {\n        knownFragmentNames[fragmentName] = node.name;\n      }\n\n      return false;\n    },\n  };\n}\n","import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { isCompositeType } from '../../type/definition.mjs';\nimport { doTypesOverlap } from '../../utilities/typeComparators.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreadsRule(context) {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n\n      if (\n        isCompositeType(fragType) &&\n        isCompositeType(parentType) &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n\n      if (\n        fragType &&\n        parentType &&\n        !doTypesOverlap(context.getSchema(), fragType, parentType)\n      ) {\n        const parentTypeStr = inspect(parentType);\n        const fragTypeStr = inspect(fragType);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${fragName}\" cannot be spread here as objects of type \"${parentTypeStr}\" can never be of type \"${fragTypeStr}\".`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n\n  if (frag) {\n    const type = typeFromAST(context.getSchema(), frag.typeCondition);\n\n    if (isCompositeType(type)) {\n      return type;\n    }\n  }\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No fragment cycles\n *\n * The graph of fragment spreads must not form any cycles including spreading itself.\n * Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data.\n *\n * See https://spec.graphql.org/draft/#sec-Fragment-spreads-must-not-form-cycles\n */\nexport function NoFragmentCyclesRule(context) {\n  // Tracks already visited fragments to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors\n\n  const spreadPath = []; // Position in the spread path\n\n  const spreadPathIndexByName = Object.create(null);\n  return {\n    OperationDefinition: () => false,\n\n    FragmentDefinition(node) {\n      detectCycleRecursive(node);\n      return false;\n    },\n  }; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(fragment) {\n    if (visitedFrags[fragment.name.value]) {\n      return;\n    }\n\n    const fragmentName = fragment.name.value;\n    visitedFrags[fragmentName] = true;\n    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);\n\n    if (spreadNodes.length === 0) {\n      return;\n    }\n\n    spreadPathIndexByName[fragmentName] = spreadPath.length;\n\n    for (const spreadNode of spreadNodes) {\n      const spreadName = spreadNode.name.value;\n      const cycleIndex = spreadPathIndexByName[spreadName];\n      spreadPath.push(spreadNode);\n\n      if (cycleIndex === undefined) {\n        const spreadFragment = context.getFragment(spreadName);\n\n        if (spreadFragment) {\n          detectCycleRecursive(spreadFragment);\n        }\n      } else {\n        const cyclePath = spreadPath.slice(cycleIndex);\n        const viaPath = cyclePath\n          .slice(0, -1)\n          .map((s) => '\"' + s.name.value + '\"')\n          .join(', ');\n        context.reportError(\n          new GraphQLError(\n            `Cannot spread fragment \"${spreadName}\" within itself` +\n              (viaPath !== '' ? ` via ${viaPath}.` : '.'),\n            {\n              nodes: cyclePath,\n            },\n          ),\n        );\n      }\n\n      spreadPath.pop();\n    }\n\n    spreadPathIndexByName[fragmentName] = undefined;\n  }\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique variable names\n *\n * A GraphQL operation is only valid if all its variables are uniquely named.\n */\nexport function UniqueVariableNamesRule(context) {\n  return {\n    OperationDefinition(operationNode) {\n      var _operationNode$variab;\n\n      // See: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const variableDefinitions =\n        (_operationNode$variab = operationNode.variableDefinitions) !== null &&\n        _operationNode$variab !== void 0\n          ? _operationNode$variab\n          : [];\n      const seenVariableDefinitions = groupBy(\n        variableDefinitions,\n        (node) => node.variable.name.value,\n      );\n\n      for (const [variableName, variableNodes] of seenVariableDefinitions) {\n        if (variableNodes.length > 1) {\n          context.reportError(\n            new GraphQLError(\n              `There can be only one variable named \"$${variableName}\".`,\n              {\n                nodes: variableNodes.map((node) => node.variable.name),\n              },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No undefined variables\n *\n * A GraphQL operation is only valid if all variables encountered, both directly\n * and via fragment spreads, are defined by that operation.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variable-Uses-Defined\n */\nexport function NoUndefinedVariablesRule(context) {\n  let variableNameDefined = Object.create(null);\n  return {\n    OperationDefinition: {\n      enter() {\n        variableNameDefined = Object.create(null);\n      },\n\n      leave(operation) {\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          const varName = node.name.value;\n\n          if (variableNameDefined[varName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${varName}\" is not defined by operation \"${operation.name.value}\".`\n                  : `Variable \"$${varName}\" is not defined.`,\n                {\n                  nodes: [node, operation],\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(node) {\n      variableNameDefined[node.variable.name.value] = true;\n    },\n  };\n}\n","import { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * No unused variables\n *\n * A GraphQL operation is only valid if all variables defined by an operation\n * are used, either directly or within a spread fragment.\n *\n * See https://spec.graphql.org/draft/#sec-All-Variables-Used\n */\nexport function NoUnusedVariablesRule(context) {\n  let variableDefs = [];\n  return {\n    OperationDefinition: {\n      enter() {\n        variableDefs = [];\n      },\n\n      leave(operation) {\n        const variableNameUsed = Object.create(null);\n        const usages = context.getRecursiveVariableUsages(operation);\n\n        for (const { node } of usages) {\n          variableNameUsed[node.name.value] = true;\n        }\n\n        for (const variableDef of variableDefs) {\n          const variableName = variableDef.variable.name.value;\n\n          if (variableNameUsed[variableName] !== true) {\n            context.reportError(\n              new GraphQLError(\n                operation.name\n                  ? `Variable \"$${variableName}\" is never used in operation \"${operation.name.value}\".`\n                  : `Variable \"$${variableName}\" is never used.`,\n                {\n                  nodes: variableDef,\n                },\n              ),\n            );\n          }\n        }\n      },\n    },\n\n    VariableDefinition(def) {\n      variableDefs.push(def);\n    },\n  };\n}\n","import { groupBy } from '../../jsutils/groupBy.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\n\n/**\n * Unique argument definition names\n *\n * A GraphQL Object or Interface type is only valid if all its fields have uniquely named arguments.\n * A GraphQL Directive is only valid if all its arguments are uniquely named.\n */\nexport function UniqueArgumentDefinitionNamesRule(context) {\n  return {\n    DirectiveDefinition(directiveNode) {\n      var _directiveNode$argume;\n\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n      const argumentNodes =\n        (_directiveNode$argume = directiveNode.arguments) !== null &&\n        _directiveNode$argume !== void 0\n          ? _directiveNode$argume\n          : [];\n      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);\n    },\n\n    InterfaceTypeDefinition: checkArgUniquenessPerField,\n    InterfaceTypeExtension: checkArgUniquenessPerField,\n    ObjectTypeDefinition: checkArgUniquenessPerField,\n    ObjectTypeExtension: checkArgUniquenessPerField,\n  };\n\n  function checkArgUniquenessPerField(typeNode) {\n    var _typeNode$fields;\n\n    const typeName = typeNode.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n    /* c8 ignore next */\n\n    const fieldNodes =\n      (_typeNode$fields = typeNode.fields) !== null &&\n      _typeNode$fields !== void 0\n        ? _typeNode$fields\n        : [];\n\n    for (const fieldDef of fieldNodes) {\n      var _fieldDef$arguments;\n\n      const fieldName = fieldDef.name.value; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n      /* c8 ignore next */\n\n      const argumentNodes =\n        (_fieldDef$arguments = fieldDef.arguments) !== null &&\n        _fieldDef$arguments !== void 0\n          ? _fieldDef$arguments\n          : [];\n      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);\n    }\n\n    return false;\n  }\n\n  function checkArgUniqueness(parentName, argumentNodes) {\n    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);\n\n    for (const [argName, argNodes] of seenArgs) {\n      if (argNodes.length > 1) {\n        context.reportError(\n          new GraphQLError(\n            `Argument \"${parentName}(${argName}:)\" can only be defined once.`,\n            {\n              nodes: argNodes.map((node) => node.name),\n            },\n          ),\n        );\n      }\n    }\n\n    return false;\n  }\n}\n","import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  constructor(ast, onError) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error) {\n    this._onError(error);\n  }\n\n  getDocument() {\n    return this._ast;\n  }\n\n  getFragment(name) {\n    let fragments;\n\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n\n      this._fragments = fragments;\n    }\n\n    return fragments[name];\n  }\n\n  getFragmentSpreads(node) {\n    let spreads = this._fragmentSpreads.get(node);\n\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit = [node];\n      let set;\n\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n\n      this._fragmentSpreads.set(node, spreads);\n    }\n\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(operation) {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = Object.create(null);\n      const nodesToVisit = [operation.selectionSet];\n      let node;\n\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n\n          if (collectedNames[fragName] !== true) {\n            collectedNames[fragName] = true;\n            const fragment = this.getFragment(fragName);\n\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n\n    return fragments;\n  }\n}\nexport class SDLValidationContext extends ASTValidationContext {\n  constructor(ast, schema, onError) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n}\nexport class ValidationContext extends ASTValidationContext {\n  constructor(schema, ast, typeInfo, onError) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  getSchema() {\n    return this._schema;\n  }\n\n  getVariableUsages(node) {\n    let usages = this._variableUsages.get(node);\n\n    if (!usages) {\n      const newUsages = [];\n      const typeInfo = new TypeInfo(this._schema);\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n\n          Variable(variable) {\n            newUsages.push({\n              node: variable,\n              type: typeInfo.getInputType(),\n              defaultValue: typeInfo.getDefaultValue(),\n            });\n          },\n        }),\n      );\n      usages = newUsages;\n\n      this._variableUsages.set(node, usages);\n    }\n\n    return usages;\n  }\n\n  getRecursiveVariableUsages(operation) {\n    let usages = this._recursiveVariableUsages.get(operation);\n\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n\n    return usages;\n  }\n\n  getType() {\n    return this._typeInfo.getType();\n  }\n\n  getParentType() {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType() {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType() {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef() {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective() {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument() {\n    return this._typeInfo.getArgument();\n  }\n\n  getEnumValue() {\n    return this._typeInfo.getEnumValue();\n  }\n}\n","import { devAssert } from '../jsutils/devAssert.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { visit, visitInParallel } from '../language/visitor.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.mjs';\nimport { specifiedRules, specifiedSDLRules } from './specifiedRules.mjs';\nimport {\n  SDLValidationContext,\n  ValidationContext,\n} from './ValidationContext.mjs';\n/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Validate will stop validation after a `maxErrors` limit has been reached.\n * Attackers can send pathologically invalid queries to induce a DoS attack,\n * so by default `maxErrors` set to 100 errors.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */\n\nexport function validate(\n  schema,\n  documentAST,\n  rules = specifiedRules,\n  options,\n  /** @deprecated will be removed in 17.0.0 */\n  typeInfo = new TypeInfo(schema),\n) {\n  var _options$maxErrors;\n\n  const maxErrors =\n    (_options$maxErrors =\n      options === null || options === void 0 ? void 0 : options.maxErrors) !==\n      null && _options$maxErrors !== void 0\n      ? _options$maxErrors\n      : 100;\n  documentAST || devAssert(false, 'Must provide document.'); // If the schema used for validation is invalid, throw an error.\n\n  assertValidSchema(schema);\n  const abortObj = Object.freeze({});\n  const errors = [];\n  const context = new ValidationContext(\n    schema,\n    documentAST,\n    typeInfo,\n    (error) => {\n      if (errors.length >= maxErrors) {\n        errors.push(\n          new GraphQLError(\n            'Too many validation errors, error limit reached. Validation aborted.',\n          ),\n        ); // eslint-disable-next-line @typescript-eslint/no-throw-literal\n\n        throw abortObj;\n      }\n\n      errors.push(error);\n    },\n  ); // This uses a specialized visitor which runs multiple visitors in parallel,\n  // while maintaining the visitor skip and break API.\n\n  const visitor = visitInParallel(rules.map((rule) => rule(context))); // Visit the whole document with each instance of all provided rules.\n\n  try {\n    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));\n  } catch (e) {\n    if (e !== abortObj) {\n      throw e;\n    }\n  }\n\n  return errors;\n}\n/**\n * @internal\n */\n\nexport function validateSDL(\n  documentAST,\n  schemaToExtend,\n  rules = specifiedSDLRules,\n) {\n  const errors = [];\n  const context = new SDLValidationContext(\n    documentAST,\n    schemaToExtend,\n    (error) => {\n      errors.push(error);\n    },\n  );\n  const visitors = rules.map((rule) => rule(context));\n  visit(documentAST, visitInParallel(visitors));\n  return errors;\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDL(documentAST) {\n  const errors = validateSDL(documentAST);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */\n\nexport function assertValidSDLExtension(documentAST, schema) {\n  const errors = validateSDL(documentAST, schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n","import { invariant } from '../../../jsutils/invariant.mjs';\nimport { GraphQLError } from '../../../error/GraphQLError.mjs';\nimport { getNamedType, isInputObjectType } from '../../../type/definition.mjs';\n\n/**\n * No deprecated\n *\n * A GraphQL document is only valid if all selected fields and all used enum values have not been\n * deprecated.\n *\n * Note: This rule is optional and is not part of the Validation section of the GraphQL\n * Specification. The main purpose of this rule is detection of deprecated usages and not\n * necessarily to forbid their use when querying a service.\n */\nexport function NoDeprecatedCustomRule(context) {\n  return {\n    Field(node) {\n      const fieldDef = context.getFieldDef();\n      const deprecationReason =\n        fieldDef === null || fieldDef === void 0\n          ? void 0\n          : fieldDef.deprecationReason;\n\n      if (fieldDef && deprecationReason != null) {\n        const parentType = context.getParentType();\n        parentType != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n\n    Argument(node) {\n      const argDef = context.getArgument();\n      const deprecationReason =\n        argDef === null || argDef === void 0\n          ? void 0\n          : argDef.deprecationReason;\n\n      if (argDef && deprecationReason != null) {\n        const directiveDef = context.getDirective();\n\n        if (directiveDef != null) {\n          context.reportError(\n            new GraphQLError(\n              `Directive \"@${directiveDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        } else {\n          const parentType = context.getParentType();\n          const fieldDef = context.getFieldDef();\n          (parentType != null && fieldDef != null) || invariant(false);\n          context.reportError(\n            new GraphQLError(\n              `Field \"${parentType.name}.${fieldDef.name}\" argument \"${argDef.name}\" is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    ObjectField(node) {\n      const inputObjectDef = getNamedType(context.getParentInputType());\n\n      if (isInputObjectType(inputObjectDef)) {\n        const inputFieldDef = inputObjectDef.getFields()[node.name.value];\n        const deprecationReason =\n          inputFieldDef === null || inputFieldDef === void 0\n            ? void 0\n            : inputFieldDef.deprecationReason;\n\n        if (deprecationReason != null) {\n          context.reportError(\n            new GraphQLError(\n              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,\n              {\n                nodes: node,\n              },\n            ),\n          );\n        }\n      }\n    },\n\n    EnumValue(node) {\n      const enumValueDef = context.getEnumValue();\n      const deprecationReason =\n        enumValueDef === null || enumValueDef === void 0\n          ? void 0\n          : enumValueDef.deprecationReason;\n\n      if (enumValueDef && deprecationReason != null) {\n        const enumTypeDef = getNamedType(context.getInputType());\n        enumTypeDef != null || invariant(false);\n        context.reportError(\n          new GraphQLError(\n            `The enum value \"${enumTypeDef.name}.${enumValueDef.name}\" is deprecated. ${deprecationReason}`,\n            {\n              nodes: node,\n            },\n          ),\n        );\n      }\n    },\n  };\n}\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { C as CodeMirror } from \"./codemirror.es.js\";\nimport { Kind, specifiedRules, NoUnusedFragmentsRule, ExecutableDefinitionsRule, KnownFragmentNamesRule, validate, LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, print, parse, GraphQLError, NoDeprecatedCustomRule } from \"graphql\";\nimport \"./index.es.js\";\nimport { R as Range, P as Position, C as CharacterStream } from \"./Range.es.js\";\nimport { o as onlineParser } from \"./onlineParser.es.js\";\nimport \"react\";\nimport \"react-dom\";\nconst specifiedSDLRules = [\n  LoneSchemaDefinitionRule,\n  UniqueOperationTypesRule,\n  UniqueTypeNamesRule,\n  UniqueEnumValueNamesRule,\n  UniqueFieldDefinitionNamesRule,\n  UniqueDirectiveNamesRule,\n  KnownTypeNamesRule,\n  KnownDirectivesRule,\n  UniqueDirectivesPerLocationRule,\n  PossibleTypeExtensionsRule,\n  UniqueArgumentNamesRule,\n  UniqueInputFieldNamesRule\n];\nfunction validateWithCustomRules(schema, ast, customRules, isRelayCompatMode, isSchemaDocument) {\n  const rules = specifiedRules.filter((rule) => {\n    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {\n      return false;\n    }\n    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {\n      return false;\n    }\n    return true;\n  });\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n  if (isSchemaDocument) {\n    Array.prototype.push.apply(rules, specifiedSDLRules);\n  }\n  const errors = validate(schema, ast, rules);\n  return errors.filter((error) => {\n    if (error.message.indexOf(\"Unknown directive\") !== -1 && error.nodes) {\n      const node = error.nodes[0];\n      if (node && node.kind === Kind.DIRECTIVE) {\n        const name = node.name.value;\n        if (name === \"arguments\" || name === \"argumentDefinitions\") {\n          return false;\n        }\n      }\n    }\n    return true;\n  });\n}\n__name(validateWithCustomRules, \"validateWithCustomRules\");\nconst SEVERITY$1 = {\n  Error: \"Error\",\n  Warning: \"Warning\",\n  Information: \"Information\",\n  Hint: \"Hint\"\n};\nconst DIAGNOSTIC_SEVERITY = {\n  [SEVERITY$1.Error]: 1,\n  [SEVERITY$1.Warning]: 2,\n  [SEVERITY$1.Information]: 3,\n  [SEVERITY$1.Hint]: 4\n};\nconst invariant = /* @__PURE__ */ __name((condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n}, \"invariant\");\nfunction getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {\n  var _a, _b;\n  let ast = null;\n  if (externalFragments) {\n    if (typeof externalFragments === \"string\") {\n      query += \"\\n\\n\" + externalFragments;\n    } else {\n      query += \"\\n\\n\" + externalFragments.reduce((agg, node) => {\n        agg += print(node) + \"\\n\\n\";\n        return agg;\n      }, \"\");\n    }\n  }\n  try {\n    ast = parse(query);\n  } catch (error) {\n    if (error instanceof GraphQLError) {\n      const range = getRange((_b = (_a = error.locations) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : { line: 0, column: 0 }, query);\n      return [\n        {\n          severity: DIAGNOSTIC_SEVERITY.Error,\n          message: error.message,\n          source: \"GraphQL: Syntax\",\n          range\n        }\n      ];\n    }\n    throw error;\n  }\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\n__name(getDiagnostics, \"getDiagnostics\");\nfunction validateQuery(ast, schema = null, customRules, isRelayCompatMode) {\n  if (!schema) {\n    return [];\n  }\n  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Error, \"Validation\"));\n  const deprecationWarningAnnotations = mapCat(validate(schema, ast, [NoDeprecatedCustomRule]), (error) => annotations(error, DIAGNOSTIC_SEVERITY.Warning, \"Deprecation\"));\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n}\n__name(validateQuery, \"validateQuery\");\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n__name(mapCat, \"mapCat\");\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n  const highlightedNodes = [];\n  error.nodes.forEach((node) => {\n    const highlightNode = node.kind !== \"Variable\" && \"name\" in node && node.name !== void 0 ? node.name : \"variable\" in node && node.variable !== void 0 ? node.variable : node;\n    if (highlightNode) {\n      invariant(error.locations, \"GraphQL validation error requires locations.\");\n      const loc = error.locations[0];\n      const highlightLoc = getLocation(highlightNode);\n      const end = loc.column + (highlightLoc.end - highlightLoc.start);\n      highlightedNodes.push({\n        source: `GraphQL: ${type}`,\n        message: error.message,\n        severity,\n        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))\n      });\n    }\n  });\n  return highlightedNodes;\n}\n__name(annotations, \"annotations\");\nfunction getRange(location, queryText) {\n  const parser = onlineParser();\n  const state = parser.startState();\n  const lines = queryText.split(\"\\n\");\n  invariant(lines.length >= location.line, \"Query text must have more lines than where the error happened\");\n  let stream = null;\n  for (let i = 0; i < location.line; i++) {\n    stream = new CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      const style = parser.token(stream, state);\n      if (style === \"invalidchar\") {\n        break;\n      }\n    }\n  }\n  invariant(stream, \"Expected Parser stream to be available.\");\n  const line = location.line - 1;\n  const start = stream.getStartOfToken();\n  const end = stream.getCurrentPosition();\n  return new Range(new Position(line, start), new Position(line, end));\n}\n__name(getRange, \"getRange\");\nfunction getLocation(node) {\n  const typeCastedNode = node;\n  const location = typeCastedNode.loc;\n  invariant(location, \"Expected ASTNode to have a location.\");\n  return location;\n}\n__name(getLocation, \"getLocation\");\nconst SEVERITY = [\"error\", \"warning\", \"information\", \"hint\"];\nconst TYPE = {\n  \"GraphQL: Validation\": \"validation\",\n  \"GraphQL: Deprecation\": \"deprecation\",\n  \"GraphQL: Syntax\": \"syntax\"\n};\nCodeMirror.registerHelper(\"lint\", \"graphql\", (text, options) => {\n  const schema = options.schema;\n  const rawResults = getDiagnostics(text, schema, options.validationRules, void 0, options.externalFragments);\n  const results = rawResults.map((error) => ({\n    message: error.message,\n    severity: error.severity ? SEVERITY[error.severity - 1] : SEVERITY[0],\n    type: error.source ? TYPE[error.source] : void 0,\n    from: CodeMirror.Pos(error.range.start.line, error.range.start.character),\n    to: CodeMirror.Pos(error.range.end.line, error.range.end.character)\n  }));\n  return results;\n});\n","var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { i as isIgnored, L as LexRules, P as ParseRules } from \"./index.es.js\";\nimport { Kind } from \"graphql\";\nfunction onlineParser(options = {\n  eatWhitespace: (stream) => stream.eatWhile(isIgnored),\n  lexRules: LexRules,\n  parseRules: ParseRules,\n  editorConfig: {}\n}) {\n  return {\n    startState() {\n      const initialState = {\n        level: 0,\n        step: 0,\n        name: null,\n        kind: null,\n        type: null,\n        rule: null,\n        needsSeparator: false,\n        prevState: null\n      };\n      pushRule(options.parseRules, initialState, Kind.DOCUMENT);\n      return initialState;\n    },\n    token(stream, state) {\n      return getToken(stream, state, options);\n    }\n  };\n}\n__name(onlineParser, \"onlineParser\");\nfunction getToken(stream, state, options) {\n  var _a;\n  if (state.inBlockstring) {\n    if (stream.match(/.*\"\"\"/)) {\n      state.inBlockstring = false;\n      return \"string\";\n    } else {\n      stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n  if (state.rule && state.rule.length === 0) {\n    popRule(state);\n  } else if (state.needsAdvance) {\n    state.needsAdvance = false;\n    advanceRule(state, true);\n  }\n  if (stream.sol()) {\n    const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;\n    state.indentLevel = Math.floor(stream.indentation() / tabSize);\n  }\n  if (eatWhitespace(stream)) {\n    return \"ws\";\n  }\n  const token = lex(lexRules, stream);\n  if (!token) {\n    const matchedSomething = stream.match(/\\S+/);\n    if (!matchedSomething) {\n      stream.match(/\\s/);\n    }\n    pushRule(SpecialParseRules, state, \"Invalid\");\n    return \"invalidchar\";\n  }\n  if (token.kind === \"Comment\") {\n    pushRule(SpecialParseRules, state, \"Comment\");\n    return \"comment\";\n  }\n  const backupState = assign({}, state);\n  if (token.kind === \"Punctuation\") {\n    if (/^[{([]/.test(token.value)) {\n      if (state.indentLevel !== void 0) {\n        state.levels = (state.levels || []).concat(state.indentLevel + 1);\n      }\n    } else if (/^[})\\]]/.test(token.value)) {\n      const levels = state.levels = (state.levels || []).slice(0, -1);\n      if (state.indentLevel) {\n        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {\n          state.indentLevel = levels[levels.length - 1];\n        }\n      }\n    }\n  }\n  while (state.rule) {\n    let expected = typeof state.rule === \"function\" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];\n    if (state.needsSeparator) {\n      expected = expected === null || expected === void 0 ? void 0 : expected.separator;\n    }\n    if (expected) {\n      if (expected.ofRule) {\n        expected = expected.ofRule;\n      }\n      if (typeof expected === \"string\") {\n        pushRule(parseRules, state, expected);\n        continue;\n      }\n      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token)) {\n        if (expected.update) {\n          expected.update(state, token);\n        }\n        if (token.kind === \"Punctuation\") {\n          advanceRule(state, true);\n        } else {\n          state.needsAdvance = true;\n        }\n        return expected.style;\n      }\n    }\n    unsuccessful(state);\n  }\n  assign(state, backupState);\n  pushRule(SpecialParseRules, state, \"Invalid\");\n  return \"invalidchar\";\n}\n__name(getToken, \"getToken\");\nfunction assign(to, from) {\n  const keys = Object.keys(from);\n  for (let i = 0; i < keys.length; i++) {\n    to[keys[i]] = from[keys[i]];\n  }\n  return to;\n}\n__name(assign, \"assign\");\nconst SpecialParseRules = {\n  Invalid: [],\n  Comment: []\n};\nfunction pushRule(rules, state, ruleKind) {\n  if (!rules[ruleKind]) {\n    throw new TypeError(\"Unknown rule: \" + ruleKind);\n  }\n  state.prevState = Object.assign({}, state);\n  state.kind = ruleKind;\n  state.name = null;\n  state.type = null;\n  state.rule = rules[ruleKind];\n  state.step = 0;\n  state.needsSeparator = false;\n}\n__name(pushRule, \"pushRule\");\nfunction popRule(state) {\n  if (!state.prevState) {\n    return;\n  }\n  state.kind = state.prevState.kind;\n  state.name = state.prevState.name;\n  state.type = state.prevState.type;\n  state.rule = state.prevState.rule;\n  state.step = state.prevState.step;\n  state.needsSeparator = state.prevState.needsSeparator;\n  state.prevState = state.prevState.prevState;\n}\n__name(popRule, \"popRule\");\nfunction advanceRule(state, successful) {\n  var _a;\n  if (isList(state) && state.rule) {\n    const step = state.rule[state.step];\n    if (step.separator) {\n      const separator = step.separator;\n      state.needsSeparator = !state.needsSeparator;\n      if (!state.needsSeparator && separator.ofRule) {\n        return;\n      }\n    }\n    if (successful) {\n      return;\n    }\n  }\n  state.needsSeparator = false;\n  state.step++;\n  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n    popRule(state);\n    if (state.rule) {\n      if (isList(state)) {\n        if ((_a = state.rule) === null || _a === void 0 ? void 0 : _a[state.step].separator) {\n          state.needsSeparator = !state.needsSeparator;\n        }\n      } else {\n        state.needsSeparator = false;\n        state.step++;\n      }\n    }\n  }\n}\n__name(advanceRule, \"advanceRule\");\nfunction isList(state) {\n  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== \"string\" && state.rule[state.step];\n  return step && step.isList;\n}\n__name(isList, \"isList\");\nfunction unsuccessful(state) {\n  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n    popRule(state);\n  }\n  if (state.rule) {\n    advanceRule(state, false);\n  }\n}\n__name(unsuccessful, \"unsuccessful\");\nfunction lex(lexRules, stream) {\n  const kinds = Object.keys(lexRules);\n  for (let i = 0; i < kinds.length; i++) {\n    const match = stream.match(lexRules[kinds[i]]);\n    if (match && match instanceof Array) {\n      return { kind: kinds[i], value: match[0] };\n    }\n  }\n}\n__name(lex, \"lex\");\nexport { onlineParser as o };\n"],"names":["__defProp","Object","defineProperty","__name","target","value","configurable","CharacterStream","sourceText","this","getStartOfToken","_start","getCurrentPosition","_pos","eol","_sourceText","length","sol","peek","charAt","next","char","eat","pattern","_testNextCharacter","eatWhile","match","isMatched","didEat","eatSpace","skipToEnd","skipTo","position","consume","caseFold","token","regex","RegExp","test","substr","slice","Array","startsWith","backUp","num","column","indentation","indent","whiteSpaces","pos","charCodeAt","current","character","Range","start","end","containsPosition","line","Position","lessThanOrEqualTo","LoneSchemaDefinitionRule","context","_ref","_ref2","_oldSchema$astNode","oldSchema","getSchema","alreadyDefined","astNode","getQueryType","getMutationType","getSubscriptionType","schemaDefinitionsCount","SchemaDefinition","node","reportError","GraphQLError","nodes","UniqueOperationTypesRule","schema","definedOperationTypes","create","existingOperationTypes","query","mutation","subscription","checkOperationTypes","SchemaExtension","_node$operationTypes","operationTypesNodes","operationTypes","operationType","operation","alreadyDefinedOperationType","UniqueTypeNamesRule","knownTypeNames","ScalarTypeDefinition","checkTypeName","ObjectTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","InputObjectTypeDefinition","typeName","name","getType","UniqueEnumValueNamesRule","existingTypeMap","getTypeMap","knownValueNames","checkValueUniqueness","EnumTypeExtension","_node$values","valueNodes","values","valueNames","valueDef","valueName","existingType","isEnumType","getValue","UniqueFieldDefinitionNamesRule","knownFieldNames","checkFieldUniqueness","InputObjectTypeExtension","InterfaceTypeExtension","ObjectTypeExtension","_node$fields","fieldNodes","fields","fieldNames","fieldDef","fieldName","hasField","type","isObjectType","isInterfaceType","isInputObjectType","getFields","UniqueDirectiveNamesRule","knownDirectiveNames","DirectiveDefinition","directiveName","getDirective","isExecutableDefinitionNode","kind","Kind","isTypeSystemDefinitionNode","isTypeDefinitionNode","isTypeSystemExtensionNode","isTypeExtensionNode","KnownTypeNamesRule","existingTypesMap","definedTypes","getDocument","definitions","def","typeNames","keys","NamedType","_1","parent","_2","ancestors","_ancestors$","definitionNode","isSDL","standardTypeNames","includes","suggestedTypes","suggestionList","concat","didYouMean","specifiedScalarTypes","introspectionTypes","map","KnownDirectivesRule","locationsMap","definedDirectives","getDirectives","specifiedDirectives","directive","locations","astDefinitions","Directive","_key","_parent","_path","candidateLocation","appliedTo","invariant","OperationTypeNode","DirectiveLocation","getDirectiveLocationForOperation","parentNode","inspect","getDirectiveLocationForASTPath","UniqueDirectivesPerLocationRule","uniqueDirectiveMap","isRepeatable","repeatable","schemaDirectives","typeDirectivesMap","enter","directives","seenDirectives","undefined","PossibleTypeExtensionsRule","ScalarTypeExtension","checkExtension","UnionTypeExtension","expectedKind","defNode","defKindToExtKind","isScalarType","isUnionType","typeToExtKind","kindStr","extensionKindToTypeName","allTypeNames","groupBy","list","keyFn","result","Map","item","key","group","get","set","push","UniqueArgumentNamesRule","Field","checkArgUniqueness","_parentNode$arguments","seenArgs","arguments","arg","argName","argNodes","UniqueInputFieldNamesRule","knownNameStack","knownNames","ObjectValue","leave","prevKnownNames","pop","ObjectField","ExecutableDefinitionsRule","Document","definition","defName","KnownArgumentNamesOnDirectivesRule","directiveArgs","args","_def$arguments","argsNodes","directiveNode","knownArgs","argNode","suggestions","KnownFragmentNamesRule","FragmentSpread","fragmentName","getFragment","NoUnusedFragmentsRule","operationDefs","fragmentDefs","OperationDefinition","FragmentDefinition","fragmentNameUsed","getRecursivelyReferencedFragments","fragmentDef","fragName","sortValueNode","valueNode","fieldNode","sort","fieldA","fieldB","naturalCompare","reasonMessage","reason","isArray","responseName","subReason","join","collectConflictsBetweenFieldsAndFragment","conflicts","cachedFieldsAndFragmentNames","comparedFragmentPairs","areMutuallyExclusive","fieldMap","fragment","getReferencedFieldsAndFragmentNames","fieldMap2","referencedFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","collectConflictsBetweenFragments","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","parentFieldsAreMutuallyExclusive","entries","fields1","fields2","field1","conflict","findConflict","field2","parentType1","node1","def1","parentType2","node2","def2","name1","name2","stringifyArguments","type1","type2","doTypesConflict","selectionSet1","selectionSet","selectionSet2","getFieldsAndFragmentNames","fragmentNames1","fragmentNames2","findConflictsBetweenSubSelectionSets","getNamedType","flat","subfieldConflicts","_fieldNode$arguments","inputObjectWithArgs","print","isListType","ofType","isNonNullType","isLeafType","parentType","cached","nodeAndDefs","fragmentNames","_collectFieldsAndFragmentNames","fragmentType","typeFromAST","typeCondition","selections","selection","alias","inlineFragmentType","PairSet","_data","a","b","_this$_data$get","key1","key2","ProvidedRequiredArgumentsOnDirectivesRule","_schema$getDirectives","requiredArgsMap","keyMap","filter","isRequiredArgument","isRequiredArgumentNode","requiredArgs","_directiveNode$argume","argNodeMap","Set","argDef","argType","isType","defaultValue","getDirectiveValues","directiveDef","variableValues","_node$directives","find","_node$arguments","coercedValues","argumentNodes","argumentNode","isNull","variableName","hasOwnProperty","coercedValue","valueFromAST","getArgumentValues","obj","prop","prototype","call","collectFieldsImpl","fragments","runtimeType","visitedFragmentNames","shouldIncludeNode","fieldList","doesFragmentConditionMatch","skip","GraphQLSkipDirective","if","include","GraphQLIncludeDirective","typeConditionNode","conditionalType","isAbstractType","isSubType","isValidValueNode","locationType","getInputType","parseLiteral","typeStr","error","message","originalError","allowedVariableUsage","varType","varDefaultValue","locationDefaultValue","nullableLocationType","isTypeSubTypeOf","specifiedRules","freeze","knownOperationNames","operationName","operationCount","subscriptionType","document","collectFields","size","extraFieldSelections","InlineFragment","isCompositeType","VariableDefinition","isInputType","variable","getParentType","getFieldDef","suggestion","usageCount","getPossibleTypes","possibleType","getInterfaces","_usageCount$possibleI","possibleInterface","typeA","typeB","usageCountDiff","x","getSuggestedTypeNames","possibleFieldNames","getSuggestedFieldNames","knownFragmentNames","fragType","doTypesOverlap","parentTypeStr","fragTypeStr","frag","getFragmentType","visitedFrags","spreadPath","spreadPathIndexByName","detectCycleRecursive","spreadNodes","getFragmentSpreads","spreadNode","spreadName","cycleIndex","spreadFragment","cyclePath","viaPath","s","operationNode","_operationNode$variab","seenVariableDefinitions","variableDefinitions","variableNodes","variableNameDefined","usages","getRecursiveVariableUsages","varName","variableDefs","variableNameUsed","variableDef","Argument","getArgument","knownArgsNames","ListValue","getNullableType","getParentInputType","fieldNodeMap","field","isRequiredInputField","NullValue","EnumValue","IntValue","FloatValue","StringValue","BooleanValue","providedArgs","argTypeStr","varDefMap","varDef","varTypeStr","SelectionSet","i","j","collectConflictsWithin","findConflictsWithinSelectionSet","reasonMsg","checkArgUniquenessPerField","typeNode","_typeNode$fields","_fieldDef$arguments","parentName","ASTValidationContext","ast","onError","_ast","_fragments","_fragmentSpreads","_recursivelyReferencedFragments","_onError","spreads","setsToVisit","collectedNames","nodesToVisit","Symbol","toStringTag","ValidationContext","typeInfo","_schema","_typeInfo","_variableUsages","_recursiveVariableUsages","newUsages","TypeInfo","visit","visitWithTypeInfo","Variable","getDefaultValue","getVariableUsages","getEnumValue","validate","documentAST","_options$maxErrors","rules","options","maxErrors","devAssert","assertValidSchema","abortObj","errors","visitor","visitInParallel","rule","e","NoDeprecatedCustomRule","deprecationReason","inputObjectDef","inputFieldDef","enumValueDef","enumTypeDef","specifiedSDLRules","validateWithCustomRules","customRules","isRelayCompatMode","isSchemaDocument","apply","indexOf","SEVERITY$1","DIAGNOSTIC_SEVERITY","condition","Error","getDiagnostics","_a","_b","externalFragments","reduce","agg","parse","range","getRange","severity","source","validateQuery","validationErrorAnnotations","mapCat","annotations","deprecationWarningAnnotations","Warning","array","mapper","highlightedNodes","forEach","highlightNode","loc","highlightLoc","getLocation","location","queryText","parser","onlineParser","state","startState","lines","split","stream","SEVERITY","TYPE","CodeMirror","text","validationRules","from","to","eatWhitespace","isIgnored","lexRules","LexRules","parseRules","ParseRules","editorConfig","initialState","level","step","needsSeparator","prevState","pushRule","getToken","inBlockstring","popRule","needsAdvance","advanceRule","tabSize","indentLevel","Math","floor","lex","SpecialParseRules","backupState","assign","levels","expected","separator","ofRule","update","style","unsuccessful","Invalid","Comment","ruleKind","TypeError","successful","isList","kinds"],"sourceRoot":""}