{"version":3,"file":"static/js/972.f7106757.chunk.js","mappings":"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","sources":["../../../node_modules/@graphiql/react/dist/foldgutter.es.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nimport { a as codemirror } from \"./codemirror.es.js\";\nfunction _mergeNamespaces(n, m) {\n  m.forEach(function(e) {\n    e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n      if (k !== \"default\" && !(k in n)) {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function() {\n            return e[k];\n          }\n        });\n      }\n    });\n  });\n  return Object.freeze(n);\n}\n__name(_mergeNamespaces, \"_mergeNamespaces\");\nvar foldgutter$2 = { exports: {} };\nvar foldcode = { exports: {} };\n(function(module, exports) {\n  (function(mod) {\n    mod(codemirror.exports);\n  })(function(CodeMirror) {\n    function doFold(cm, pos, options, force) {\n      if (options && options.call) {\n        var finder = options;\n        options = null;\n      } else {\n        var finder = getOption(cm, options, \"rangeFinder\");\n      }\n      if (typeof pos == \"number\")\n        pos = CodeMirror.Pos(pos, 0);\n      var minSize = getOption(cm, options, \"minFoldSize\");\n      function getRange(allowFolded) {\n        var range2 = finder(cm, pos);\n        if (!range2 || range2.to.line - range2.from.line < minSize)\n          return null;\n        if (force === \"fold\")\n          return range2;\n        var marks = cm.findMarksAt(range2.from);\n        for (var i = 0; i < marks.length; ++i) {\n          if (marks[i].__isFold) {\n            if (!allowFolded)\n              return null;\n            range2.cleared = true;\n            marks[i].clear();\n          }\n        }\n        return range2;\n      }\n      __name(getRange, \"getRange\");\n      var range = getRange(true);\n      if (getOption(cm, options, \"scanUp\"))\n        while (!range && pos.line > cm.firstLine()) {\n          pos = CodeMirror.Pos(pos.line - 1, 0);\n          range = getRange(false);\n        }\n      if (!range || range.cleared || force === \"unfold\")\n        return;\n      var myWidget = makeWidget(cm, options, range);\n      CodeMirror.on(myWidget, \"mousedown\", function(e) {\n        myRange.clear();\n        CodeMirror.e_preventDefault(e);\n      });\n      var myRange = cm.markText(range.from, range.to, {\n        replacedWith: myWidget,\n        clearOnEnter: getOption(cm, options, \"clearOnEnter\"),\n        __isFold: true\n      });\n      myRange.on(\"clear\", function(from, to) {\n        CodeMirror.signal(cm, \"unfold\", cm, from, to);\n      });\n      CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n    }\n    __name(doFold, \"doFold\");\n    function makeWidget(cm, options, range) {\n      var widget = getOption(cm, options, \"widget\");\n      if (typeof widget == \"function\") {\n        widget = widget(range.from, range.to);\n      }\n      if (typeof widget == \"string\") {\n        var text = document.createTextNode(widget);\n        widget = document.createElement(\"span\");\n        widget.appendChild(text);\n        widget.className = \"CodeMirror-foldmarker\";\n      } else if (widget) {\n        widget = widget.cloneNode(true);\n      }\n      return widget;\n    }\n    __name(makeWidget, \"makeWidget\");\n    CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n      return function(cm, pos) {\n        doFold(cm, pos, { rangeFinder, widget });\n      };\n    };\n    CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n      doFold(this, pos, options, force);\n    });\n    CodeMirror.defineExtension(\"isFolded\", function(pos) {\n      var marks = this.findMarksAt(pos);\n      for (var i = 0; i < marks.length; ++i)\n        if (marks[i].__isFold)\n          return true;\n    });\n    CodeMirror.commands.toggleFold = function(cm) {\n      cm.foldCode(cm.getCursor());\n    };\n    CodeMirror.commands.fold = function(cm) {\n      cm.foldCode(cm.getCursor(), null, \"fold\");\n    };\n    CodeMirror.commands.unfold = function(cm) {\n      cm.foldCode(cm.getCursor(), { scanUp: false }, \"unfold\");\n    };\n    CodeMirror.commands.foldAll = function(cm) {\n      cm.operation(function() {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n          cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"fold\");\n      });\n    };\n    CodeMirror.commands.unfoldAll = function(cm) {\n      cm.operation(function() {\n        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n          cm.foldCode(CodeMirror.Pos(i, 0), { scanUp: false }, \"unfold\");\n      });\n    };\n    CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n      var funcs = Array.prototype.slice.call(arguments, 0);\n      return function(cm, start) {\n        for (var i = 0; i < funcs.length; ++i) {\n          var found = funcs[i](cm, start);\n          if (found)\n            return found;\n        }\n      };\n    });\n    CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n      var helpers = cm.getHelpers(start, \"fold\");\n      for (var i = 0; i < helpers.length; i++) {\n        var cur = helpers[i](cm, start);\n        if (cur)\n          return cur;\n      }\n    });\n    var defaultOptions = {\n      rangeFinder: CodeMirror.fold.auto,\n      widget: \"\\u2194\",\n      minFoldSize: 0,\n      scanUp: false,\n      clearOnEnter: true\n    };\n    CodeMirror.defineOption(\"foldOptions\", null);\n    function getOption(cm, options, name) {\n      if (options && options[name] !== void 0)\n        return options[name];\n      var editorOptions = cm.options.foldOptions;\n      if (editorOptions && editorOptions[name] !== void 0)\n        return editorOptions[name];\n      return defaultOptions[name];\n    }\n    __name(getOption, \"getOption\");\n    CodeMirror.defineExtension(\"foldOption\", function(options, name) {\n      return getOption(this, options, name);\n    });\n  });\n})();\n(function(module, exports) {\n  (function(mod) {\n    mod(codemirror.exports, foldcode.exports);\n  })(function(CodeMirror) {\n    CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n      if (old && old != CodeMirror.Init) {\n        cm.clearGutter(cm.state.foldGutter.options.gutter);\n        cm.state.foldGutter = null;\n        cm.off(\"gutterClick\", onGutterClick);\n        cm.off(\"changes\", onChange);\n        cm.off(\"viewportChange\", onViewportChange);\n        cm.off(\"fold\", onFold);\n        cm.off(\"unfold\", onFold);\n        cm.off(\"swapDoc\", onChange);\n      }\n      if (val) {\n        cm.state.foldGutter = new State(parseOptions(val));\n        updateInViewport(cm);\n        cm.on(\"gutterClick\", onGutterClick);\n        cm.on(\"changes\", onChange);\n        cm.on(\"viewportChange\", onViewportChange);\n        cm.on(\"fold\", onFold);\n        cm.on(\"unfold\", onFold);\n        cm.on(\"swapDoc\", onChange);\n      }\n    });\n    var Pos = CodeMirror.Pos;\n    function State(options) {\n      this.options = options;\n      this.from = this.to = 0;\n    }\n    __name(State, \"State\");\n    function parseOptions(opts) {\n      if (opts === true)\n        opts = {};\n      if (opts.gutter == null)\n        opts.gutter = \"CodeMirror-foldgutter\";\n      if (opts.indicatorOpen == null)\n        opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n      if (opts.indicatorFolded == null)\n        opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n      return opts;\n    }\n    __name(parseOptions, \"parseOptions\");\n    function isFolded(cm, line) {\n      var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold) {\n          var fromPos = marks[i].find(-1);\n          if (fromPos && fromPos.line === line)\n            return marks[i];\n        }\n      }\n    }\n    __name(isFolded, \"isFolded\");\n    function marker(spec) {\n      if (typeof spec == \"string\") {\n        var elt = document.createElement(\"div\");\n        elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n        return elt;\n      } else {\n        return spec.cloneNode(true);\n      }\n    }\n    __name(marker, \"marker\");\n    function updateFoldInfo(cm, from, to) {\n      var opts = cm.state.foldGutter.options, cur = from - 1;\n      var minSize = cm.foldOption(opts, \"minFoldSize\");\n      var func = cm.foldOption(opts, \"rangeFinder\");\n      var clsFolded = typeof opts.indicatorFolded == \"string\" && classTest(opts.indicatorFolded);\n      var clsOpen = typeof opts.indicatorOpen == \"string\" && classTest(opts.indicatorOpen);\n      cm.eachLine(from, to, function(line) {\n        ++cur;\n        var mark = null;\n        var old = line.gutterMarkers;\n        if (old)\n          old = old[opts.gutter];\n        if (isFolded(cm, cur)) {\n          if (clsFolded && old && clsFolded.test(old.className))\n            return;\n          mark = marker(opts.indicatorFolded);\n        } else {\n          var pos = Pos(cur, 0);\n          var range = func && func(cm, pos);\n          if (range && range.to.line - range.from.line >= minSize) {\n            if (clsOpen && old && clsOpen.test(old.className))\n              return;\n            mark = marker(opts.indicatorOpen);\n          }\n        }\n        if (!mark && !old)\n          return;\n        cm.setGutterMarker(line, opts.gutter, mark);\n      });\n    }\n    __name(updateFoldInfo, \"updateFoldInfo\");\n    function classTest(cls) {\n      return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n    }\n    __name(classTest, \"classTest\");\n    function updateInViewport(cm) {\n      var vp = cm.getViewport(), state = cm.state.foldGutter;\n      if (!state)\n        return;\n      cm.operation(function() {\n        updateFoldInfo(cm, vp.from, vp.to);\n      });\n      state.from = vp.from;\n      state.to = vp.to;\n    }\n    __name(updateInViewport, \"updateInViewport\");\n    function onGutterClick(cm, line, gutter) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      if (gutter != opts.gutter)\n        return;\n      var folded = isFolded(cm, line);\n      if (folded)\n        folded.clear();\n      else\n        cm.foldCode(Pos(line, 0), opts);\n    }\n    __name(onGutterClick, \"onGutterClick\");\n    function onChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      state.from = state.to = 0;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function() {\n        updateInViewport(cm);\n      }, opts.foldOnChangeTimeSpan || 600);\n    }\n    __name(onChange, \"onChange\");\n    function onViewportChange(cm) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var opts = state.options;\n      clearTimeout(state.changeUpdate);\n      state.changeUpdate = setTimeout(function() {\n        var vp = cm.getViewport();\n        if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n          updateInViewport(cm);\n        } else {\n          cm.operation(function() {\n            if (vp.from < state.from) {\n              updateFoldInfo(cm, vp.from, state.from);\n              state.from = vp.from;\n            }\n            if (vp.to > state.to) {\n              updateFoldInfo(cm, state.to, vp.to);\n              state.to = vp.to;\n            }\n          });\n        }\n      }, opts.updateViewportTimeSpan || 400);\n    }\n    __name(onViewportChange, \"onViewportChange\");\n    function onFold(cm, from) {\n      var state = cm.state.foldGutter;\n      if (!state)\n        return;\n      var line = from.line;\n      if (line >= state.from && line < state.to)\n        updateFoldInfo(cm, line, line + 1);\n    }\n    __name(onFold, \"onFold\");\n  });\n})();\nvar foldgutter = foldgutter$2.exports;\nvar foldgutter$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ _mergeNamespaces({\n  __proto__: null,\n  [Symbol.toStringTag]: \"Module\",\n  \"default\": foldgutter\n}, [foldgutter$2.exports]));\nexport { foldgutter$1 as f };\n"],"names":["__defProp","Object","defineProperty","__name","target","value","configurable","_mergeNamespaces","n","m","forEach","e","Array","isArray","keys","k","d","getOwnPropertyDescriptor","get","enumerable","freeze","foldgutter$2","exports","CodeMirror","doFold","cm","pos","options","force","call","finder","getOption","Pos","minSize","getRange","allowFolded","range2","to","line","from","marks","findMarksAt","i","length","__isFold","cleared","clear","range","firstLine","myWidget","makeWidget","on","myRange","e_preventDefault","markText","replacedWith","clearOnEnter","signal","widget","text","document","createTextNode","createElement","appendChild","className","cloneNode","newFoldFunction","rangeFinder","defineExtension","this","commands","toggleFold","foldCode","getCursor","fold","unfold","scanUp","foldAll","operation","lastLine","unfoldAll","registerHelper","funcs","prototype","slice","arguments","start","found","helpers","getHelpers","cur","defaultOptions","auto","minFoldSize","name","editorOptions","foldOptions","defineOption","mod","codemirror","val","old","Init","clearGutter","state","foldGutter","gutter","off","onGutterClick","onChange","onViewportChange","onFold","State","parseOptions","updateInViewport","opts","indicatorOpen","indicatorFolded","isFolded","findMarks","fromPos","find","marker","spec","elt","updateFoldInfo","foldOption","func","clsFolded","classTest","clsOpen","eachLine","mark","gutterMarkers","test","setGutterMarker","cls","RegExp","vp","getViewport","folded","clearTimeout","changeUpdate","setTimeout","foldOnChangeTimeSpan","updateViewportTimeSpan","foldgutter","foldgutter$1","__proto__","Symbol","toStringTag"],"sourceRoot":""}